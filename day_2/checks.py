# @Time    : 2026-01-08 19:34
# @Author  : Hector Astrom
# @Email   : hastrom@mit.edu
# @File    : checks.py

# DO NOT EDIT THIS FILE

import __main__ as NOTEBOOK_SCOPE  # context from notebook
from typing import Callable
from datetime import datetime
import hashlib
import os
import json
import sqlite3
import mongomock


###############################
# Helpers - REUSABLE CODE
###############################
class Check:  # stub
    pass


check_registry: dict[str, Check] = dict()  # maps check_id : Check() instance


class Check:
    def __init__(self, check_id: str, check_function: Callable):
        self.check_id = check_id
        self.last_ran = None
        self.check_function = check_function  # particular check instance logic
        check_registry[check_id] = self  # class instance

    def __call__(self, *args, update_time=True, **kwds):
        if update_time:
            self.last_ran = datetime.now()  # keep track of last time it ran

        return self.check_function(*args, **kwds)


def run_check(check_id: str, *args, silent=False, **kwargs):
    assert check_id in check_registry, f"ERROR: Missing check for exercise {check_id}"
    
    if not silent:
        print(f"Running check for exercise {check_id}...\n")
 
    try:
        check_registry[check_id](*args, **kwargs)
        # Invariant: checks must throw a DESCRIPTIVE error if they fail
        # otherwise, they've passed!
        if not silent:
            print(f"Passed Exercise {check_id}!")
        return True
    except Exception as e:
        if not silent:
            print(f"Exercise {check_id} failed due to: {type(e).__name__}")
            print(f"'{e}'")
        raise


def is_defined(variable_name: str):
    if hasattr(NOTEBOOK_SCOPE, variable_name):
        return True
    raise NameError(f"'{variable_name}' is not defined in the notebook!")


def get_var(variable_name: str):
    if is_defined(variable_name):
        return getattr(NOTEBOOK_SCOPE, variable_name)


def get_func(func_name: str) -> Callable:
    """Helper specifically for grabbing and validating student functions"""
    f = get_var(func_name)
    if not callable(f):
        raise TypeError(
            f"'{func_name}' was found, but it is not a function. Check your syntax!"
        )
    return f


def verify_var_change(variable_name: str):
    assert get_var(variable_name) != "EDIT ME", (
        f"You forgot to edit '{variable_name}'. "
        f"\nFIX: Scroll up, edit '{variable_name}' where it says 'EDIT ME', and rerun the cell"
    )


def assert_return_not_edit_me(value, exercise_id: str):
    if value == "EDIT ME":
        raise AssertionError(
            f"exercise {exercise_id} return value is still 'EDIT ME'. "
            f"Fix the exercise and rerun the cell."
        )


# for file integrity verification
def get_file_hash() -> str:
    """Generates a SHA-256 hash of the current file's content."""
    with open(__file__, "rb") as f:
        # any change triggers a completely new hash
        return hashlib.sha256(f.read()).hexdigest()[:12]  # shortened


def run_all_checks(skip_checks: list[str] = None) -> tuple[dict, float]:
    """
    Runs all checks, prints a status table, and provides an integrity hash.
    """
    skip_checks = skip_checks or []
    check_stats = {}
    total_correct = 0

    # generate fingerprint of the checks.py file
    integrity_fingerprint = get_file_hash()

    # start printing table
    print(f"\n{'='*50}")
    print(f"{'EXERCISE CHECKER SUMMARY':^50}")
    print(f"{'Integrity Hash: ' + integrity_fingerprint:^50}")
    print(f"{'='*50}\n")

    header = f"{'Exercise':<12} | {'Status':<10} | {'Last Verified'}"
    print(header)
    print("-" * len(header))

    for check_id, check in check_registry.items():
        if check_id in skip_checks:
            continue

        try:
            # Invariant: Checks pass if no exception is raised
            check(update_time=False)
            status_icon = "✓ Correct"
            passed = True
            total_correct += 1
        except Exception:
            status_icon = "✗ Wrong"
            passed = False

        last_ran_str = (
            check.last_ran.strftime("%m-%d %H:%M") if check.last_ran else "NEVER"
        )
        check_stats[check_id] = (passed, last_ran_str)

        # Print table row
        print(f"{check_id:<12} | {status_icon:<10} | {last_ran_str}")

    # Final Score logic
    num_checks = len(check_registry) - len(skip_checks)
    score_pct = (total_correct / num_checks) if num_checks > 0 else 0

    print(f"\n{'-'*50}")
    print(f"Completed: {total_correct}/{num_checks} ({score_pct:.1%})")
    print(f"{'-'*50}\n")

    return check_stats, score_pct


###############################
# Specific checks
###############################
# RECIPE:
# 1. Define check logic: throw error when it fails, do nothing on success
# 2. Initialize Check instance, which adds check to the registry

###############################
# Section 0 Checks
###############################
check_0_1 = Check("0.1", lambda: None)


###############################
# Helper utilities for checks
###############################
def _reset_temp_db():
    if os.path.exists("temp.db"):
        os.remove("temp.db")


def _exec_sql(script: str):
    with sqlite3.connect("temp.db") as conn:
        conn.execute("PRAGMA foreign_keys = ON;")
        conn.executescript(script)
        conn.commit()


def _query_sql(script: str):
    with sqlite3.connect("temp.db") as conn:
        conn.execute("PRAGMA foreign_keys = ON;")
        cur = conn.execute(script)
        return cur.fetchall()


def _assert_no_placeholder(value, exercise_id: str):
    text = value if isinstance(value, str) else json.dumps(value)
    if "EDIT ME" in text:
        raise AssertionError(
            f"exercise {exercise_id} still contains 'EDIT ME' placeholders."
        )


###############################
# Section 1 Checks - SQL
###############################
def _check_1_1():
    _reset_temp_db()
    func = get_func("exercise_1_1")
    sql_command = func()
    _assert_no_placeholder(sql_command, "1.1")
    assert isinstance(sql_command, str), "exercise 1.1 must return a SQL string."

    with sqlite3.connect("temp.db") as conn:
        info = conn.execute("PRAGMA table_info('Students');").fetchall()

    assert info, "Students table was not created."
    names = [col[1] for col in info]
    assert ["id", "name", "age", "favorite_food"] == names, (
        "Students table must have columns: id, name, age, favorite_food"
    )
    id_col = [col for col in info if col[1] == "id"][0]
    assert id_col[5] == 1, "id must be the PRIMARY KEY for Students."
    assert "INT" in id_col[2].upper(), "id column must be an integer primary key."


check_1_1 = Check("1.1", _check_1_1)


def _check_1_2():
    _reset_temp_db()
    get_func("exercise_1_1")()
    func = get_func("exercise_1_2")
    sql_command = func()
    _assert_no_placeholder(sql_command, "1.2")

    rows = _query_sql("SELECT id, name, age, favorite_food FROM Students;")
    assert rows, "No rows inserted into Students in exercise 1.2."
    first = rows[0]
    assert isinstance(first[0], int), "id should be an integer."
    assert isinstance(first[1], str), "name should be text."


check_1_2 = Check("1.2", _check_1_2)


def _check_1_3():
    _reset_temp_db()
    get_func("exercise_1_1")()
    get_func("exercise_1_2")()
    func = get_func("exercise_1_3")
    sql_script = func()
    _assert_no_placeholder(sql_script, "1.3")

    rows = _query_sql("SELECT id, name, age, favorite_food FROM Students;")
    assert len(rows) >= 4, "Need at least four students after exercise 1.3."
    joey = [r for r in rows if r[1] == "Joey" and r[2] == 19]
    elena = [r for r in rows if r[1] == "Elena" and r[2] == 21]
    assert joey, "Joey (age 19, burgers) must be inserted."
    assert elena, "Elena (age 21, risotto) must be inserted."
    assert any(r[3].lower() == "burgers" for r in joey), "Joey's favorite_food should be burgers."
    assert any(r[3].lower() == "risotto" for r in elena), "Elena's favorite_food should be risotto."


check_1_3 = Check("1.3", _check_1_3)


def _check_1_4():
    _reset_temp_db()
    # Seed database with prior exercises
    get_func("exercise_1_1")()
    get_func("exercise_1_2")()
    get_func("exercise_1_3")()

    func = get_func("exercise_1_4")
    sql_query, results = func()
    _assert_no_placeholder(sql_query, "1.4")
    expected = _query_sql("SELECT name, age FROM Students WHERE age >= 21;")
    assert isinstance(results, list), "Results should be a list of tuples."
    assert sorted(results) == sorted(expected), (
        "Query in exercise 1.4 should select (name, age) where age >= 21."
    )
    assert expected, "The query should return at least one student (e.g., Elena)."


check_1_4 = Check("1.4", _check_1_4)


###############################
# Section 2 Checks - Mongo basics
###############################
def _check_2_1():
    func = get_func("exercise_2_1")
    client, database, cars_collection, customers_collection = func()

    assert isinstance(client, mongomock.MongoClient), "client must be a mongomock.MongoClient."
    assert hasattr(database, "name") and database.name == "cannizzaro_cars", (
        "Database should be named 'cannizzaro_cars'."
    )
    assert cars_collection.name == "cars", "First collection must be 'cars'."
    assert customers_collection.name == "customers", "Second collection must be 'customers'."
    assert cars_collection.database.name == "cannizzaro_cars", "cars collection should belong to cannizzaro_cars."
    assert customers_collection.database.name == "cannizzaro_cars", "customers collection should belong to cannizzaro_cars."


check_2_1 = Check("2.1", _check_2_1)


def _check_2_2():
    func = get_func("exercise_2_2")
    cars_collection, garage_snapshot = func()

    assert isinstance(cars_collection, mongomock.collection.Collection), "cars_collection must be a collection."
    assert cars_collection.count_documents({}) >= 3, "Insert at least three cars in exercise 2.2."
    assert isinstance(garage_snapshot, list), "garage_snapshot should be a list."
    assert len(garage_snapshot) >= 3, "garage_snapshot should contain at least three cars."
    for car in garage_snapshot:
        assert "_id" not in car, "garage_snapshot should omit '_id' fields."
        _assert_no_placeholder(json.dumps(car), "2.2")
        assert "make" in car and "model" in car, "Each car should include make and model."


check_2_2 = Check("2.2", _check_2_2)


def _check_2_3():
    func = get_func("exercise_2_3")
    query_filter, results_list = func()

    assert isinstance(query_filter, dict), "query_filter must be a dict."
    color = query_filter.get("color")
    year_filter = query_filter.get("year")
    assert isinstance(color, str) and color.lower() == "red", "Filter must target red cars."
    assert isinstance(year_filter, dict), "Year filter should use a comparison operator."
    comparator_value = year_filter.get("$gt", year_filter.get("$gte"))
    assert isinstance(comparator_value, int) and comparator_value > 2018 - 1, (
        "Year filter should require cars newer than 2018."
    )

    assert isinstance(results_list, list), "results_list should be a list."
    for doc in results_list:
        assert "_id" not in doc, "Projection should exclude _id."
        assert doc.get("color", "").lower() == "red", "Returned cars must be red."
        assert doc.get("year", 0) > 2018, "Returned cars must be newer than 2018."


check_2_3 = Check("2.3", _check_2_3)


def _check_2_4():
    func = get_func("exercise_2_4")
    update_filter, delete_filter, garage_snapshot = func()
    _assert_no_placeholder(update_filter, "2.4")
    _assert_no_placeholder(delete_filter, "2.4")

    assert isinstance(garage_snapshot, list), "garage_snapshot should be a list."
    assert all(car.get("year", 9999) >= 2016 for car in garage_snapshot), (
        "Cars with year < 2016 should have been removed."
    )
    detailed = [car for car in garage_snapshot if car.get("status") == "detailed" and car.get("km") == 0]
    assert detailed, "At least one car should be updated to km=0 and status='detailed'."


check_2_4 = Check("2.4", _check_2_4)


###############################
# Section 3 Checks - SQL to NoSQL
###############################
def _check_3_1():
    func = get_func("exercise_3_1")
    sql_query, nosql_filter, nosql_projection, results = func()

    _assert_no_placeholder(sql_query, "3.1")
    query_lower = sql_query.lower().replace(" ", "")
    assert "selectmake,model,price" in query_lower, (
        "SQL query should select make, model, and price."
    )
    assert "status='available'" in query_lower, "SQL query should filter status = 'available'."
    assert "price<=30000" in query_lower, "SQL query should limit price to <= 30000."

    _assert_no_placeholder(nosql_filter, "3.1")
    _assert_no_placeholder(nosql_projection, "3.1")
    assert isinstance(nosql_filter, dict), "nosql_filter must be a dictionary."
    assert nosql_filter.get("status") == "available", "nosql_filter must require status='available'."
    price_filter = nosql_filter.get("price", {})
    assert isinstance(price_filter, dict), "nosql_filter['price'] should be a dict with a comparison operator."
    comp_value = price_filter.get("$lte", price_filter.get("$lt"))
    assert isinstance(comp_value, int) and comp_value <= 30000, "nosql_filter must cap price at 30000."

    expected_projection = {"_id": 0, "make": 1, "model": 1, "price": 1}
    assert nosql_projection == expected_projection, (
        "nosql_projection should include make, model, price and hide _id."
    )

    assert isinstance(results, list), "results should be a list of documents."
    for doc in results:
        assert isinstance(doc, dict), "Each result should be a dictionary."
        assert "_id" not in doc, "Projection should remove _id from results."
        assert "price" in doc, "Each result should include price."
        if isinstance(doc["price"], (int, float)):
            assert doc["price"] <= 30000, "Returned prices must be <= 30000."

    numeric_prices = [doc["price"] for doc in results if isinstance(doc.get("price"), (int, float))]
    if len(numeric_prices) >= 2:
        assert numeric_prices == sorted(numeric_prices, reverse=True), (
            "Results should be sorted by price in descending order."
        )


check_3_1 = Check("3.1", _check_3_1)


def _check_3_2():
    func = get_func("exercise_3_2")
    sql_command, inserted_doc = func()

    _assert_no_placeholder(sql_command, "3.2")
    _assert_no_placeholder(inserted_doc, "3.2")
    sql_lower = sql_command.lower().replace(" ", "")
    assert "createtablecars" in sql_lower, "SQL should create the Cars table."
    assert "priceinteger" in sql_lower and "status" in sql_lower, (
        "SQL should define price as INTEGER and include status."
    )

    required_fields = {"make", "model", "year", "price", "status"}
    assert isinstance(inserted_doc, dict), "Inserted document should be a dictionary."
    assert required_fields.issubset(inserted_doc.keys()), (
        "example_car should include make, model, year, price, and status."
    )
    assert "_id" not in inserted_doc, "Inserted document should be returned without _id."
    assert isinstance(inserted_doc.get("year"), int), "year should be an integer."
    assert isinstance(inserted_doc.get("price"), int), "price should be an integer."
    assert isinstance(inserted_doc.get("make"), str), "make should be text."
    assert isinstance(inserted_doc.get("model"), str), "model should be text."
    assert isinstance(inserted_doc.get("status"), str), "status should be text."


check_3_2 = Check("3.2", _check_3_2)


def _check_3_3():
    func = get_func("exercise_3_3")
    sql_insert, nosql_doc, inserted_without_id = func()

    _assert_no_placeholder(sql_insert, "3.3")
    _assert_no_placeholder(nosql_doc, "3.3")
    sql_lower = sql_insert.lower()
    assert "insert into cars" in sql_lower and "lancia" in sql_lower and "ypsilon" in sql_lower, (
        "SQL insert should target Cars and insert the provided Lancia Ypsilon values."
    )

    expected = {
        "make": "Lancia",
        "model": "Ypsilon",
        "year": 2020,
        "price": 14000,
        "status": "available",
    }
    assert nosql_doc == expected, "nosql_doc should mirror the provided INSERT values."
    assert inserted_without_id == expected, "inserted_without_id should match the inserted document without _id."


check_3_3 = Check("3.3", _check_3_3)


###############################
# Section B Checks - Bonus
###############################
def _seed_students_for_bonus():
    _reset_temp_db()
    seed_sql = """
        CREATE TABLE Students (
            id INTEGER PRIMARY KEY,
            name TEXT,
            age INTEGER,
            favorite_food TEXT
        );

        INSERT INTO Students (id, name, age, favorite_food) VALUES
            (1, 'You', 25, 'pizza'),
            (2, 'Mattia', 22, 'pasta'),
            (3, 'Joey', 19, 'burgers'),
            (4, 'Elena', 21, 'risotto'),
            (5, 'Partner', 23, 'gelato');
    """
    _exec_sql(seed_sql)


def _check_2_5():
    _seed_students_for_bonus()
    func = get_func("exercise_b_1")
    create_table_sql, insert_sql, query_sql_text, query_results = func()

    _assert_no_placeholder(create_table_sql, "2.5")
    _assert_no_placeholder(insert_sql, "2.5")
    _assert_no_placeholder(query_sql_text, "2.5")

    # Friends table exists with proper columns
    info = _query_sql("PRAGMA table_info('Friends');")
    names = [col[1] for col in info]
    assert ["id", "first_student_id", "second_student_id"] == names, (
        "Friends table must have id, first_student_id, second_student_id columns."
    )

    fk_list = _query_sql("PRAGMA foreign_key_list('Friends');")
    referenced = [fk[2] for fk in fk_list]
    assert referenced.count("Students") >= 2, "Both foreign keys must reference Students(id)."

    friends_rows = _query_sql("SELECT * FROM Friends;")
    assert len(friends_rows) == 3, "Insert three friend relationships in exercise 2.5."

    expected_results = _query_sql(query_sql_text)
    assert sorted(query_results) == sorted(expected_results), (
        "query_results must match executing query_sql_text against the Friends table."
    )
    assert expected_results, "Your friend query should return at least one name."


check_2_5 = Check("2.5", _check_2_5)


def _check_2_6():
    func = get_func("exercise_b_2")
    car_doc, customer_doc, joined_view = func()

    assert isinstance(car_doc, dict), "car_doc should be a dictionary."
    assert "_id" in car_doc, "car_doc must include the inserted _id."
    _assert_no_placeholder(str(car_doc), "2.6")

    assert isinstance(customer_doc, dict), "customer_doc should be a dictionary."
    _assert_no_placeholder(str(customer_doc), "2.6")
    assert "car_id" in customer_doc, "customer_doc must reference car_id."
    assert customer_doc["car_id"] == car_doc["_id"], "customer_doc.car_id must match car_doc._id."

    assert isinstance(joined_view, dict), "joined_view should be a dictionary."
    _assert_no_placeholder(str(joined_view), "2.6")
    linked_candidates = [
        joined_view.get("car_id"),
        joined_view.get("car", {}).get("_id") if isinstance(joined_view.get("car"), dict) else None,
        joined_view.get("car_doc", {}).get("_id") if isinstance(joined_view.get("car_doc"), dict) else None,
    ]
    assert any(link_id == car_doc["_id"] for link_id in linked_candidates), (
        "joined_view should include the linked car id."
    )
    if "customer" in joined_view and isinstance(joined_view["customer"], dict):
        assert joined_view["customer"].get("car_id") == customer_doc["car_id"], (
            "joined_view.customer should reference the same car_id."
        )


check_2_6 = Check("2.6", _check_2_6)
