# @Time    : 2026-01-13
# @Author  : Hector Astrom
# @Email   : hastrom@mit.edu
# @File    : day_3_checks.py

# DO NOT EDIT THIS FILE

import __main__ as NOTEBOOK_SCOPE  # notebook context
from typing import Callable, Any, Dict, List, Tuple
from datetime import datetime
import os
import hashlib
import json

from bson import ObjectId
from pymongo.mongo_client import MongoClient


###############################
# Check framework
###############################
class Check:
    pass


check_registry: Dict[str, Check] = {}


class Check:
    def __init__(self, check_id: str, check_function: Callable[[], Any]):
        self.check_id = check_id
        self.last_ran = None
        self.check_function = check_function
        check_registry[check_id] = self

    def __call__(self, *args, update_time: bool = True, **kwargs):
        if update_time:
            self.last_ran = datetime.now()
        return self.check_function(*args, **kwargs)


def run_check(check_id: str, *args, silent: bool = False, **kwargs) -> bool:
    assert check_id in check_registry, f"ERROR: Missing check for exercise {check_id}"

    if not silent:
        print(f"Running check for exercise {check_id}...\n")

    try:
        check_registry[check_id](*args, **kwargs)
        if not silent:
            print(f"Passed Exercise {check_id}!")
        return True
    except Exception as e:
        if not silent:
            print(f"Exercise {check_id} failed due to: {type(e).__name__}")
            print(f"'{e}'")
        raise


def get_file_hash() -> str:
    with open(__file__, "rb") as f:
        return hashlib.sha256(f.read()).hexdigest()[:12]


def run_all_checks(skip_checks: List[str] | None = None) -> Tuple[Dict[str, Tuple[bool, str]], float]:
    import sys
    import io

    skip_checks = skip_checks or []
    check_stats: Dict[str, Tuple[bool, str]] = {}
    total_correct = 0

    integrity_fingerprint = get_file_hash()

    print("\n" + "=" * 60)
    print(f"{'EXERCISE CHECKER SUMMARY':^60}")
    print(f"{'Integrity Hash: ' + integrity_fingerprint:^60}")
    print("=" * 60 + "\n")

    header = f"{'Exercise':<12} | {'Status':<10} | {'Last Verified'}"
    print(header)
    print("-" * len(header))

    for check_id, check in check_registry.items():
        if check_id in skip_checks:
            continue

        # Suppress print output from exercise functions
        old_stdout = sys.stdout
        sys.stdout = io.StringIO()

        try:
            check(update_time=False)
            status_icon = "OK"
            passed = True
            total_correct += 1
        except Exception:
            status_icon = "WRONG"
            passed = False
        finally:
            # Restore stdout
            sys.stdout = old_stdout

        last_ran_str = check.last_ran.strftime("%m-%d %H:%M") if check.last_ran else "NEVER"
        check_stats[check_id] = (passed, last_ran_str)
        print(f"{check_id:<12} | {status_icon:<10} | {last_ran_str}")

    num_checks = len(check_registry) - len(skip_checks)
    score_pct = (total_correct / num_checks) if num_checks > 0 else 0.0

    print("\n" + "-" * 60)
    print(f"Completed: {total_correct}/{num_checks} ({score_pct:.1%})")
    print("-" * 60 + "\n")

    return check_stats, score_pct


###############################
# Notebook scope helpers
###############################
def is_defined(variable_name: str) -> bool:
    if hasattr(NOTEBOOK_SCOPE, variable_name):
        return True
    raise NameError(f"'{variable_name}' is not defined in the notebook!")


def get_var(variable_name: str):
    if is_defined(variable_name):
        return getattr(NOTEBOOK_SCOPE, variable_name)


def get_func(func_name: str) -> Callable:
    f = get_var(func_name)
    if not callable(f):
        raise TypeError(f"'{func_name}' was found, but it is not a function.")
    return f


def _assert_no_placeholder(value: Any, exercise_id: str) -> None:
    if isinstance(value, str):
        text = value
    else:
        try:
            text = json.dumps(value, default=str)
        except Exception:
            text = str(value)

    if "EDIT ME" in text:
        raise AssertionError(
            f"exercise {exercise_id} still contains 'EDIT ME'. Fix it and rerun the cell."
        )


def _require_connected_client(client: MongoClient) -> None:
    try:
        client.admin.command("ping")
    except Exception as e:
        raise ConnectionError(
            "Could not ping MongoDB Atlas. Common fixes:\n"
            "1) Check your connection string (username/password/cluster name).\n"
            "2) In Atlas: Security -> Network Access, allow your IP (or 0.0.0.0/0 for class).\n"
            "3) Make sure you installed pymongo[srv].\n"
            f"Original error: {e}"
        )


###############################
# Exercise checks
###############################
check_0_1 = Check("0.1", lambda: None)


def _check_1_1():
    func = get_func("exercise_1_1")
    atlas_uri, db_name = func()
    _assert_no_placeholder(atlas_uri, "1.1")
    _assert_no_placeholder(db_name, "1.1")
    assert isinstance(atlas_uri, str) and atlas_uri.startswith("mongodb+srv://"), (
        "atlas_uri must start with 'mongodb+srv://'."
    )
    assert isinstance(db_name, str) and len(db_name.strip()) >= 2, "db_name must be a non-empty string."


check_1_1 = Check("1.1", _check_1_1)


def _check_1_2():
    func = get_func("exercise_1_2")
    client = func()
    assert isinstance(client, MongoClient), "exercise 1.2 must return a pymongo MongoClient."
    _require_connected_client(client)


check_1_2 = Check("1.2", _check_1_2)


def _check_1_3():
    func = get_func("exercise_1_3")
    db, spotify_collection, playlists_collection, sandbox_collection = func()

    assert hasattr(db, "name"), "db should look like a pymongo Database."
    assert spotify_collection.name == "spotify", "spotify_collection should be named 'spotify'."
    assert playlists_collection.name == "playlists", "playlists_collection should be named 'playlists'."
    assert sandbox_collection.name == "sandbox", "sandbox_collection should be named 'sandbox'."
    assert spotify_collection.database.name == db.name, "Collections must belong to the same db."


check_1_3 = Check("1.3", _check_1_3)


def _check_1_4():
    func = get_func("exercise_1_4")
    doc_after_replace, doc_after_set = func()

    _assert_no_placeholder(doc_after_replace, "1.4")
    _assert_no_placeholder(doc_after_set, "1.4")

    assert isinstance(doc_after_replace, dict) and isinstance(doc_after_set, dict), "Return two dict documents."
    assert "_id" not in doc_after_replace and "_id" not in doc_after_set, "Projection should remove _id."

    assert doc_after_replace.get("name") == "demo", "doc_after_replace must keep name='demo'."
    assert doc_after_replace.get("field_b") == 999, "doc_after_replace must have field_b=999."
    assert "field_a" not in doc_after_replace, "Replacement update should remove field_a."

    assert doc_after_set.get("name") == "demo", "doc_after_set must keep name='demo'."
    assert doc_after_set.get("field_b") == 999, "doc_after_set must keep field_b=999."
    assert doc_after_set.get("field_a") == 123, "doc_after_set must set field_a=123."


check_1_4 = Check("1.4", _check_1_4)


def _check_2_1():
    func = get_func("exercise_2_1")
    csv_path = func()
    _assert_no_placeholder(csv_path, "2.1")
    assert isinstance(csv_path, str), "csv_path must be a string."
    assert os.path.exists(csv_path), f"File not found at {csv_path}"
    assert os.path.getsize(csv_path) > 1_000_000, "CSV file seems too small; did download fail?"


check_2_1 = Check("2.1", _check_2_1)


def _check_2_2():
    func = get_func("exercise_2_2")
    df = func()
    assert hasattr(df, "shape"), "exercise 2.2 must return a pandas DataFrame."
    assert "Unnamed: 0" not in df.columns, "You must drop the 'Unnamed: 0' column."

    required = {"track_id", "artists", "album_name", "track_name", "track_genre", "popularity"}
    assert required.issubset(set(df.columns)), f"Missing required columns: {required - set(df.columns)}"
    assert df.shape[0] >= 100_000, "Dataset should have around 114,000 rows. Do not drop most rows."


check_2_2 = Check("2.2", _check_2_2)


def _check_2_3():
    func = get_func("exercise_2_3")
    inserted_count = func()
    _assert_no_placeholder(inserted_count, "2.3")
    assert isinstance(inserted_count, int), "inserted_count must be an int."
    assert inserted_count >= 2000, "Upload at least 2000 documents for class exploration."

    _, spotify_collection, _, _ = get_func("exercise_1_3")()
    db_count = spotify_collection.count_documents({})
    assert db_count >= inserted_count, "Collection count should be >= inserted_count (after upload)."

    sample = spotify_collection.find_one({})
    assert isinstance(sample, dict), "Could not find any documents after upload."
    for key in ["track_id", "track_name", "artists", "track_genre"]:
        assert key in sample, f"Uploaded docs must include '{key}'."
    assert "_id" in sample and isinstance(sample["_id"], ObjectId), "MongoDB must assign an ObjectId _id."


check_2_3 = Check("2.3", _check_2_3)


def _check_2_4():
    func = get_func("exercise_2_4")
    query_filter, projection, results_list = func()

    _assert_no_placeholder(query_filter, "2.4")
    _assert_no_placeholder(projection, "2.4")
    assert isinstance(query_filter, dict) and isinstance(projection, dict), "Filter and projection must be dicts."
    assert query_filter.get("track_genre") == "acoustic", "Filter must target track_genre='acoustic'."

    pop = query_filter.get("popularity")
    assert isinstance(pop, dict) and "$gte" in pop, "Filter must include popularity with $gte."
    assert int(pop["$gte"]) == 70, "Popularity threshold must be 70."

    assert projection.get("_id") == 0, "Projection must hide _id with {'_id': 0}."
    for keep in ["track_name", "artists", "popularity", "track_genre"]:
        assert projection.get(keep) == 1, f"Projection must include {keep}."

    assert isinstance(results_list, list), "results_list must be a list."
    assert len(results_list) <= 5, "results_list should come from limit(5)."
    assert len(results_list) >= 1, "Expected at least 1 result. Did you upload data?"

    for doc in results_list:
        assert "_id" not in doc, "Projection should exclude _id."
        assert doc.get("track_genre") == "acoustic", "Returned docs must be acoustic."
        assert int(doc.get("popularity", 0)) >= 70, "Returned docs must have popularity >= 70."


check_2_4 = Check("2.4", _check_2_4)


def _check_2_5():
    func = get_func("exercise_2_5")
    oid_str, created_at_iso = func()
    _assert_no_placeholder(oid_str, "2.5")
    _assert_no_placeholder(created_at_iso, "2.5")

    assert isinstance(oid_str, str) and len(oid_str) >= 10, "oid_str must be a string ObjectId."
    oid = ObjectId(oid_str)  # will raise if invalid

    # Accept either a datetime object or an ISO format string
    if isinstance(created_at_iso, datetime):
        dt = created_at_iso
    elif isinstance(created_at_iso, str):
        dt = datetime.fromisoformat(created_at_iso)
    else:
        raise AssertionError("created_at_iso must be a datetime or ISO format string.")

    assert isinstance(dt, datetime), "created_at_iso must be parseable as a datetime."
    assert dt.year >= 2024, "ObjectId timestamp should be recent (this year or last year)."
    assert oid.generation_time.year >= 2024, "ObjectId generation_time should be recent."


check_2_5 = Check("2.5", _check_2_5)


def _check_3_1():
    func = get_func("exercise_3_1")
    query_filter, sort_spec, results_list = func()

    _assert_no_placeholder(query_filter, "3.1")
    _assert_no_placeholder(sort_spec, "3.1")
    assert isinstance(query_filter, dict), "query_filter must be a dict."
    assert query_filter.get("track_genre") == "alt-rock", "track_genre must be 'alt-rock'."

    for key, op, threshold in [
        ("popularity", "$gte", 50),
        ("energy", "$gt", 0.6),
        ("danceability", "$gt", 0.6),
    ]:
        part = query_filter.get(key)
        assert isinstance(part, dict) and op in part, f"Filter must include {key} with {op}."
        assert float(part[op]) >= threshold, f"{key} threshold too low."

    assert isinstance(sort_spec, list) and len(sort_spec) >= 2, "sort_spec must be a list of (field, direction)."
    assert sort_spec[0][0] == "popularity" and int(sort_spec[0][1]) == -1, "First sort must be popularity desc (-1)."
    assert sort_spec[1][0] == "tempo" and int(sort_spec[1][1]) == 1, "Second sort must be tempo asc (1)."

    assert isinstance(results_list, list) and len(results_list) <= 10, "Return up to 10 docs."
    assert len(results_list) >= 1, "Expected at least 1 result."

    # Validate order using numeric popularity then tempo
    def _key(doc: Dict[str, Any]) -> Tuple[int, float]:
        return (int(doc.get("popularity", 0)), float(doc.get("tempo", 0.0)))

    for doc in results_list:
        assert "_id" not in doc, "Projection should exclude _id."
        assert doc.get("track_genre") == "alt-rock", "Results must be alt-rock."
        assert "popularity" in doc and "tempo" in doc, "Include popularity and tempo in the returned documents."

    # Check ordering (popularity desc, tempo asc)
    keys = [_key(d) for d in results_list]
    for i in range(len(keys) - 1):
        a = keys[i]
        b = keys[i + 1]
        if a[0] == b[0]:
            assert a[1] <= b[1], "When popularity ties, tempo should increase."
        else:
            assert a[0] >= b[0], "Popularity should be non-increasing."


check_3_1 = Check("3.1", _check_3_1)


def _check_3_2():
    func = get_func("exercise_3_2")
    query_filter, match_count = func()

    _assert_no_placeholder(query_filter, "3.2")
    _assert_no_placeholder(match_count, "3.2")

    assert isinstance(query_filter, dict), "query_filter must be a dict."
    genre_filter = query_filter.get("track_genre")
    assert isinstance(genre_filter, dict) and "$in" in genre_filter, "track_genre must use $in."
    genres = set(genre_filter["$in"])
    assert {"acoustic", "ambient"}.issubset(genres), "Must include acoustic and ambient in $in list."

    or_part = query_filter.get("$or")
    assert isinstance(or_part, list) and len(or_part) >= 2, "Must include an $or with at least 2 conditions."

    assert isinstance(match_count, int), "match_count must be an int."

    _, spotify_collection, _, _ = get_func("exercise_1_3")()
    expected = spotify_collection.count_documents(query_filter)
    assert match_count == expected, "match_count must match count_documents(query_filter)."


check_3_2 = Check("3.2", _check_3_2)


def _check_3_3():
    func = get_func("exercise_3_3")
    genre, page_number, page_size, total_count, page_results = func()

    _assert_no_placeholder(genre, "3.3")
    _assert_no_placeholder(page_number, "3.3")
    _assert_no_placeholder(page_size, "3.3")
    _assert_no_placeholder(total_count, "3.3")
    _assert_no_placeholder(page_results, "3.3")

    assert genre == "acoustic", "genre must be 'acoustic'."
    assert page_number == 2, "page_number must be 2 (0-indexed)."
    assert page_size == 5, "page_size must be 5."

    assert isinstance(total_count, int) and total_count > 0, "total_count must be a positive int."
    assert isinstance(page_results, list) and len(page_results) <= page_size, "page_results must be a list of <= page_size."

    _, spotify_collection, _, _ = get_func("exercise_1_3")()
    expected_total = spotify_collection.count_documents({"track_genre": genre})
    assert total_count == expected_total, "total_count must match count_documents for the genre."

    # Compare by ordered track_id so projection differences do not matter.
    expected_cursor = (
        spotify_collection.find({"track_genre": genre}, {"track_id": 1, "_id": 0})
        .sort([("popularity", -1)])
        .skip(page_number * page_size)
        .limit(page_size)
    )
    expected_ids = [d.get("track_id") for d in expected_cursor]
    assert all(isinstance(d.get("track_id"), str) for d in page_results), (
        "Each page result must include track_id (string). Include it in your projection."
    )
    result_ids = [d.get("track_id") for d in page_results]
    assert result_ids == expected_ids, (
        "Your page_results are not the correct page.\n"
        "Expected the same ordered track_id list as skip+limit after sorting by popularity desc."
    )

    for doc in page_results:
        assert "_id" not in doc, "Projection should exclude _id."
        assert doc.get("track_genre") == genre, "All docs must be in the requested genre."


check_3_3 = Check("3.3", _check_3_3)


def _check_3_4():
    func = get_func("exercise_3_4")
    update_filter, update_operation, updated_doc = func()

    _assert_no_placeholder(update_filter, "3.4")
    _assert_no_placeholder(update_operation, "3.4")
    _assert_no_placeholder(updated_doc, "3.4")

    assert isinstance(update_filter, dict), "update_filter must be a dict."
    assert "track_id" in update_filter, "Filter must use track_id."
    assert isinstance(update_filter["track_id"], str) and len(update_filter["track_id"]) > 5, "track_id must be a string."

    assert isinstance(update_operation, dict), "update_operation must be a dict."
    assert "$inc" in update_operation and "$set" in update_operation, "Must use both $inc and $set."
    inc = update_operation["$inc"]
    sett = update_operation["$set"]
    assert isinstance(inc, dict) and inc.get("plays") == 1, "$inc must increment plays by 1."
    assert isinstance(sett, dict) and "last_played_by" in sett, "$set must include last_played_by."

    assert isinstance(updated_doc, dict), "updated_doc must be a dict."
    assert updated_doc.get("track_id") == update_filter["track_id"], "updated_doc must match the track_id you updated."
    assert isinstance(updated_doc.get("plays"), int) and updated_doc["plays"] >= 1, "plays must exist and be >= 1."
    assert isinstance(updated_doc.get("last_played_by"), str) and len(updated_doc["last_played_by"]) > 0, (
        "last_played_by must be a non-empty string."
    )
    assert "_id" not in updated_doc, "Projection should exclude _id."


check_3_4 = Check("3.4", _check_3_4)


# Note: Exercise 3.5 has no check (it's an exploration exercise)
# Exercises 3.5 and 3.6 from earlier versions were removed
