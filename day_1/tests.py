# tests.py
# DO NOT EDIT THIS FILE.
# It is downloaded automatically by the notebook.

from __future__ import annotations

import time
from typing import Any, Dict, List, Tuple

FRESHNESS_SECONDS = 90
FETCH_STAMP_PATH = "/content/.tests_last_fetched"

def _is_fresh() -> Tuple[bool, str]:
    """
    Best-effort deterrent against stale/modified tests:
    - Notebook writes FETCH_STAMP_PATH immediately after downloading tests.
    - We require that stamp time is recent.
    This does not make cheating impossible, but it makes "disable downloads"
    obvious (tests will fail once stale).
    """
    try:
        with open(FETCH_STAMP_PATH, "r", encoding="utf-8") as f:
            ts = float(f.read().strip())
        age = time.time() - ts
        if age <= FRESHNESS_SECONDS:
            return True, f"Fresh tests (age={age:.1f}s)"
        return False, f"Stale tests (age={age:.1f}s) - rerun the check cell"
    except Exception as e:
        return False, f"Missing freshness stamp - rerun the check cell ({e})"

def _get_main() -> Any:
    import __main__
    return __main__

def _assert(cond: bool, msg: str) -> None:
    if not cond:
        raise AssertionError(msg)

def test_exercise_1_1() -> None:
    m = _get_main()
    _assert(hasattr(m, "exercise_1_1"), "Missing function: exercise_1_1")
    fn = m.exercise_1_1

    rows = [
        {"name": "A", "daily_music_minutes": "100"},
        {"name": "B", "daily_music_minutes": "30"},
        {"name": "C", "daily_music_minutes": "90"},
    ]
    out = fn(rows)
    _assert(isinstance(out, list), "exercise_1_1 must return a list")
    _assert(out == ["A", "C"], "Expected ['A', 'C'] for minutes >= 90")

def test_exercise_1_2() -> None:
    m = _get_main()
    _assert(hasattr(m, "exercise_1_2"), "Missing function: exercise_1_2")
    fn = m.exercise_1_2

    people = [
        {"id": 1, "name": "X"},
        {"id": 2, "name": "Y"},
    ]
    out = fn(people)
    _assert(isinstance(out, list), "exercise_1_2 must return a list")
    _assert(len(out) == 2, "exercise_1_2 must preserve length")
    for p in out:
        _assert("digital_metrics" in p, "Missing 'digital_metrics' in at least one person")
        dm = p["digital_metrics"]
        _assert(isinstance(dm, dict), "'digital_metrics' must be a dict")
        _assert("avg_screen_time_min" in dm, "Missing digital_metrics.avg_screen_time_min")
        _assert("phone_pickups_daily" in dm, "Missing digital_metrics.phone_pickups_daily")

def test_exercise_2_1() -> None:
    m = _get_main()
    _assert(hasattr(m, "exercise_2_1"), "Missing function: exercise_2_1")
    fn = m.exercise_2_1

    import sqlite3
    conn = sqlite3.connect(":memory:")
    cur = conn.cursor()
    cur.execute("CREATE TABLE people (id INTEGER PRIMARY KEY, name TEXT, daily_music_minutes INTEGER);")
    cur.executemany(
        "INSERT INTO people (id, name, daily_music_minutes) VALUES (?, ?, ?);",
        [(1, "A", 100), (2, "B", 30), (3, "C", 90), (4, "D", 91)],
    )
    conn.commit()

    out = fn(cur)
    _assert(isinstance(out, list), "exercise_2_1 must return a list")
    _assert(out == [("A", 100), ("D", 91), ("C", 90)], "Unexpected SQL query result ordering/values")

TESTS = {
    "1.1": test_exercise_1_1,
    "1.2": test_exercise_1_2,
    "2.1": test_exercise_2_1,
}

def run_test(test_id: str) -> Dict[str, Any]:
    ok_fresh, fresh_msg = _is_fresh()
    if not ok_fresh:
        return {"id": test_id, "passed": False, "message": fresh_msg}

    if test_id not in TESTS:
        return {"id": test_id, "passed": False, "message": f"Unknown test id: {test_id}"}

    try:
        TESTS[test_id]()
        return {"id": test_id, "passed": True, "message": "PASS"}
    except Exception as e:
        return {"id": test_id, "passed": False, "message": f"FAIL: {e}"}

def run_all() -> List[Dict[str, Any]]:
    results: List[Dict[str, Any]] = []
    for tid in sorted(TESTS.keys()):
        results.append(run_test(tid))
    return results
