"""Exercise checks for the Day 1 notebook."""

# DO NOT EDIT THIS FILE

import __main__ as NOTEBOOK_SCOPE  # context from notebook
from typing import Callable
from datetime import datetime
import hashlib
import os
import json


###############################
# Helpers - REUSABLE CODE
###############################
class Check:  # stub
    pass


check_registry: dict[str, Check] = dict()  # maps check_id : Check() instance


class Check:
    def __init__(self, check_id: str, check_function: Callable):
        self.check_id = check_id
        self.last_ran = None
        self.check_function = check_function  # particular check instance logic
        check_registry[check_id] = self  # class instance

    def __call__(self, *args, update_time=True, **kwds):
        if update_time:
            self.last_ran = datetime.now()  # keep track of last time it ran

        return self.check_function(*args, **kwds)


def run_check(check_id: str, *args, silent=False, **kwargs):
    assert check_id in check_registry, f"ERROR: Missing check for exercise {check_id}"
    check_registry[check_id](*args, **kwargs)
    # Invariant: checks must throw a DESCRIPTIVE error if they fail
    # otherwise, they've passed!
    if not silent:
        print(f"Passed Exercise {check_id}!")
    return True


def is_defined(variable_name: str):
    if hasattr(NOTEBOOK_SCOPE, variable_name):
        return True
    raise NameError(f"'{variable_name}' is not defined in the notebook!")


def get_var(variable_name: str):
    if is_defined(variable_name):
        return getattr(NOTEBOOK_SCOPE, variable_name)


def get_func(func_name: str) -> Callable:
    """Helper specifically for grabbing and validating student functions"""
    f = get_var(func_name)
    if not callable(f):
        raise TypeError(
            f"'{func_name}' was found, but it is not a function. Check your syntax!"
        )
    return f


def verify_var_change(variable_name: str):
    assert get_var(variable_name) != "EDIT ME", (
        f"You forgot to edit '{variable_name}'. "
        f"\nFIX: Scroll up, edit '{variable_name}' where it says 'EDIT ME', and rerun the cell"
    )


def assert_return_not_edit_me(value, exercise_id: str):
    if value == "EDIT ME":
        raise AssertionError(
            f"exercise {exercise_id} return value is still 'EDIT ME'. "
            f"Fix the exercise and rerun the cell."
        )


# for file integrity verification
def get_file_hash() -> str:
    """Generates a SHA-256 hash of the current file's content."""
    with open(__file__, "rb") as f:
        # any change triggers a completely new hash
        return hashlib.sha256(f.read()).hexdigest()[:12]  # shortened


def run_all_checks(skip_checks: list[str] = None) -> tuple[dict, float]:
    """
    Runs all checks, prints a status table, and provides an integrity hash.
    """
    skip_checks = skip_checks or []
    check_stats = {}
    total_correct = 0

    # generate fingerprint of the checks.py file
    integrity_fingerprint = get_file_hash()

    # start printing table
    print(f"\n{'='*50}")
    print(f"{'EXERCISE CHECKER SUMMARY':^50}")
    print(f"{'Integrity Hash: ' + integrity_fingerprint:^50}")
    print(f"{'='*50}\n")

    header = f"{'Exercise':<12} | {'Status':<10} | {'Last Verified'}"
    print(header)
    print("-" * len(header))

    for check_id, check in check_registry.items():
        if check_id in skip_checks:
            continue

        try:
            # Invariant: Checks pass if no exception is raised
            check(update_time=False)
            status_icon = "✓ Correct"
            passed = True
            total_correct += 1
        except Exception:
            status_icon = "✗ Wrong"
            passed = False

        last_ran_str = (
            check.last_ran.strftime("%m-%d %H:%M") if check.last_ran else "NEVER"
        )
        check_stats[check_id] = (passed, last_ran_str)

        # Print table row
        print(f"{check_id:<12} | {status_icon:<10} | {last_ran_str}")

    # Final Score logic
    num_checks = len(check_registry) - len(skip_checks)
    score_pct = (total_correct / num_checks) if num_checks > 0 else 0

    print(f"\n{'-'*50}")
    print(f"Completed: {total_correct}/{num_checks} ({score_pct:.1%})")
    print(f"{'-'*50}\n")

    return check_stats, score_pct


###############################
# Specific checks
###############################
# RECIPE:
# 1. Define check logic: throw error when it fails, do nothing on success
# 2. Initialize Check instance, which adds check to the registry

###############################
# Section 0 Checks
###############################
check_0_1 = Check("0.1", lambda: None)


def check_0_2_fn():
    verify_var_change("my_name")
    verify_var_change("partners_name")


check_0_2 = Check("0.2", check_0_2_fn)

check_0_3 = Check("0.3", lambda: None)

###############################
# Section 1 Checks (Dictionaries)
###############################


def check_1_1_fn():
    f = get_func("exercise_1_1")
    student = f()
    assert_return_not_edit_me(student, "1.1")

    if not isinstance(student, dict):
        raise TypeError("exercise 1.1 must return a dictionary.")

    expected_keys = {"name", "age", "favorite_language"}
    if set(student.keys()) != expected_keys:
        raise AssertionError(
            f"exercise 1.1 must include keys {expected_keys}, got {set(student.keys())}."
        )

    if not isinstance(student["name"], str) or student["name"] == "EDIT ME":
        raise AssertionError("exercise 1.1 'name' must be your string value.")

    if not isinstance(student["age"], int) or student["age"] == 0:
        raise AssertionError("exercise 1.1 'age' must be a non-zero integer.")

    if (
        not isinstance(student["favorite_language"], str)
        or student["favorite_language"] == "EDIT ME"
    ):
        raise AssertionError(
            "exercise 1.1 'favorite_language' must be a string you chose."
        )


check_1_1 = Check("1.1", check_1_1_fn)


def check_1_2_fn():
    f = get_func("exercise_1_2")
    result = f()
    assert_return_not_edit_me(result, "1.2")

    if (
        not isinstance(result, tuple)
        or len(result) != 2
        or not isinstance(result[0], list)
        or not isinstance(result[1], dict)
    ):
        raise TypeError(
            "exercise 1.2 must return (valid_keys, example_values) where valid_keys is a list and example_values is a dict."
        )

    valid_keys, example_values = result

    expected_valid = ["hector", 3.14, ("tuple", 1), 42]
    if valid_keys != expected_valid:
        raise AssertionError(
            f"exercise 1.2 valid_keys should be {expected_valid} in the same order."
        )

    if not example_values:
        raise AssertionError("exercise 1.2 example_values cannot be empty.")

    if any(k not in expected_valid for k in example_values.keys()):
        raise AssertionError("exercise 1.2 example_values keys must come from valid_keys.")

    value_types = {type(v) for v in example_values.values()}
    if len(value_types) < 3:
        raise AssertionError(
            "exercise 1.2 example_values should demonstrate at least three different value types."
        )


check_1_2 = Check("1.2", check_1_2_fn)


def check_1_3_fn():
    f = get_func("exercise_1_3")
    phone = f()
    assert_return_not_edit_me(phone, "1.3")

    if phone != "+39-111-222":
        raise AssertionError("exercise 1.3 should return the emergency phone '+39-111-222'.")


check_1_3 = Check("1.3", check_1_3_fn)


def check_1_4_fn():
    f = get_func("exercise_1_4")
    book = f()
    assert_return_not_edit_me(book, "1.4")

    if not isinstance(book, dict):
        raise TypeError("exercise 1.4 must return a dictionary.")

    if book.get("year") != 2024:
        raise AssertionError("exercise 1.4 should update year to 2024.")

    if "pages" not in book:
        raise AssertionError("exercise 1.4 should add a 'pages' key.")

    if not isinstance(book["pages"], int) or book["pages"] <= 0:
        raise AssertionError("exercise 1.4 'pages' must be a positive integer.")

    if book.get("title") != "Intro to CS":
        raise AssertionError("exercise 1.4 should keep the same title.")


check_1_4 = Check("1.4", check_1_4_fn)

###############################
# Section 2 Checks (CSV)
###############################


def check_2_1_fn():
    f = get_func("exercise_2_1")
    path = f()
    assert_return_not_edit_me(path, "2.1")

    if not isinstance(path, str):
        raise TypeError("exercise 2.1 must return the file path string.")

    if not os.path.exists(path):
        raise AssertionError(f"exercise 2.1 could not find the file at {path}.")

    with open(path, "r", encoding="utf-8") as csvfile:
        lines = [line.strip() for line in csvfile.readlines() if line.strip()]

    if not lines or lines[0].lower() != "name,age,birthplace":
        raise AssertionError("exercise 2.1 header must be 'name,age,birthplace'.")

    expected_row = "Hector,20,Sweden"
    if all(expected_row != line for line in lines[1:]):
        raise AssertionError("exercise 2.1 must include row 'Hector,20,Sweden'.")


check_2_1 = Check("2.1", check_2_1_fn)


def check_2_3_fn():
    f = get_func("exercise_2_3")
    parsed = f()
    assert_return_not_edit_me(parsed, "2.3")

    if not isinstance(parsed, list):
        raise TypeError("exercise 2.3 must return a list.")

    expected = [
        {"name": "Hector", "age": 20, "favorite_food": "Pizza"},
        {"name": "Amina", "age": 18, "favorite_food": "Couscous"},
        {"name": "Luca", "age": 19, "favorite_food": "Pasta"},
    ]

    if len(parsed) != len(expected):
        raise AssertionError("exercise 2.3 parsed list has the wrong length.")

    for got, exp in zip(parsed, expected):
        if got.keys() != exp.keys():
            raise AssertionError("exercise 2.3 dict keys are incorrect.")
        if got.get("name") != exp["name"]:
            raise AssertionError("exercise 2.3 incorrect name value.")
        if got.get("favorite_food") != exp["favorite_food"]:
            raise AssertionError("exercise 2.3 incorrect favorite_food value.")
        if got.get("age") != exp["age"] or not isinstance(got.get("age"), int):
            raise AssertionError("exercise 2.3 age must be an int with the expected value.")


check_2_3 = Check("2.3", check_2_3_fn)

###############################
# Section 3 Checks (JSON)
###############################


def check_3_1_fn():
    f = get_func("exercise_3_1")
    obj = f()
    assert_return_not_edit_me(obj, "3.1")

    if not isinstance(obj, dict):
        raise TypeError("exercise 3.1 must return a dict.")

    if obj.get("name") != "Hector":
        raise AssertionError("exercise 3.1 name must be 'Hector'.")

    if obj.get("age") != 20:
        raise AssertionError("exercise 3.1 age must be 20.")

    hobbies = obj.get("hobbies")
    if hobbies != ["running", "painting"]:
        raise AssertionError("exercise 3.1 hobbies must be ['running', 'painting'].")


check_3_1 = Check("3.1", check_3_1_fn)


def check_3_2_fn():
    f = get_func("exercise_3_2")
    s = f()
    assert_return_not_edit_me(s, "3.2")

    if not isinstance(s, str):
        raise TypeError("exercise 3.2 must return a JSON string.")

    try:
        obj = json.loads(s)
    except Exception as e:
        raise AssertionError(f"exercise 3.2 returned invalid JSON: {e}")

    if obj.get("name") != "Marco":
        raise AssertionError("exercise 3.2 name must be 'Marco'.")

    if obj.get("age") != 19 or not isinstance(obj["age"], int):
        raise AssertionError("exercise 3.2 age must be int 19.")

    if obj.get("favorite_subjects") != ["Math", "Physics"]:
        raise AssertionError("exercise 3.2 favorite_subjects incorrect.")


check_3_2 = Check("3.2", check_3_2_fn)


def check_3_3_fn():
    f = get_func("exercise_3_3")
    result = f()
    assert_return_not_edit_me(result, "3.3")

    if not isinstance(result, tuple) or len(result) != 3:
        raise TypeError(
            "exercise 3.3 must return a tuple (age, second_hobby, avg_screen_time_min)."
        )

    age, hobby, avg = result

    if age != 18:
        raise AssertionError("exercise 3.3 age must be 18.")

    if hobby != "music":
        raise AssertionError("exercise 3.3 second hobby must be 'music'.")

    if avg != 320:
        raise AssertionError("exercise 3.3 avg_screen_time_min must be 320.")


check_3_3 = Check("3.3", check_3_3_fn)
