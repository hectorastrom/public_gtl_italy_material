# @Time    : 2026-01-05 12:57
# @Author  : Hector Astrom
# @Email   : hastrom@mit.edu
# @File    : checks.py

# DO NOT EDIT THIS FILE

import __main__ as NOTEBOOK_SCOPE  # context from notebook
from typing import Callable
from datetime import datetime
import hashlib
import os
import sqlite3
import json


###############################
# Helpers - REUSABLE CODE
###############################
class Check:  # stub
    pass


check_registry: dict[str, Check] = dict()  # maps check_id : Check() instance


class Check:
    def __init__(self, check_id: str, check_function: Callable):
        self.check_id = check_id
        self.last_ran = None
        self.check_function = check_function  # particular check instance logic
        check_registry[check_id] = self  # class instance

    def __call__(self, *args, update_time=True, **kwds):
        if update_time:
            self.last_ran = datetime.now()  # keep track of last time it ran

        return self.check_function(*args, **kwds)


def run_check(check_id: str, *args, silent=False, **kwargs):
    assert check_id in check_registry, f"ERROR: Missing check for exercise {check_id}"
    check_registry[check_id](*args, **kwargs)
    # Invariant: checks must throw a DESCRIPTIVE error if they fail
    # otherwise, they've passed!
    if not silent:
        print(f"Passed Exercise {check_id}!")
    return True


def is_defined(variable_name: str):
    if hasattr(NOTEBOOK_SCOPE, variable_name):
        return True
    raise NameError(f"'{variable_name}' is not defined in the notebook!")


def get_var(variable_name: str):
    if is_defined(variable_name):
        return getattr(NOTEBOOK_SCOPE, variable_name)


def get_func(func_name: str) -> Callable:
    """Helper specifically for grabbing and validating student functions"""
    f = get_var(func_name)
    if not callable(f):
        raise TypeError(
            f"'{func_name}' was found, but it is not a function. Check your syntax!"
        )
    return f


def verify_var_change(variable_name: str):
    assert get_var(variable_name) != "EDIT ME", (
        f"You forgot to edit '{variable_name}'. "
        f"\nFIX: Scroll up, edit '{variable_name}' where it says 'EDIT ME', and rerun the cell"
    )


def assert_return_not_edit_me(value, exercise_id: str):
    if value == "EDIT ME":
        raise AssertionError(
            f"exercise {exercise_id} return value is still 'EDIT ME'. "
            f"Fix the exercise and rerun the cell."
        )


# for file integrity verification
def get_file_hash() -> str:
    """Generates a SHA-256 hash of the current file's content."""
    with open(__file__, "rb") as f:
        # any change triggers a completely new hash
        return hashlib.sha256(f.read()).hexdigest()[:12]  # shortened


def run_all_checks(skip_checks: list[str] = None) -> tuple[dict, float]:
    """
    Runs all checks, prints a status table, and provides an integrity hash.
    """
    skip_checks = skip_checks or []
    check_stats = {}
    total_correct = 0

    # generate fingerprint of the checks.py file
    integrity_fingerprint = get_file_hash()

    # start printing table
    print(f"\n{'='*50}")
    print(f"{'EXERCISE CHECKER SUMMARY':^50}")
    print(f"{'Integrity Hash: ' + integrity_fingerprint:^50}")
    print(f"{'='*50}\n")

    header = f"{'Exercise':<12} | {'Status':<10} | {'Last Verified'}"
    print(header)
    print("-" * len(header))

    for check_id, check in check_registry.items():
        if check_id in skip_checks:
            continue

        try:
            # Invariant: Checks pass if no exception is raised
            check(update_time=False)
            status_icon = "✓ Correct"
            passed = True
            total_correct += 1
        except Exception:
            status_icon = "✗ Wrong"
            passed = False

        last_ran_str = (
            check.last_ran.strftime("%m-%d %H:%M") if check.last_ran else "NEVER"
        )
        check_stats[check_id] = (passed, last_ran_str)

        # Print table row
        print(f"{check_id:<12} | {status_icon:<10} | {last_ran_str}")

    # Final Score logic
    num_checks = len(check_registry) - len(skip_checks)
    score_pct = (total_correct / num_checks) if num_checks > 0 else 0

    print(f"\n{'-'*50}")
    print(f"Completed: {total_correct}/{num_checks} ({score_pct:.1%})")
    print(f"{'-'*50}\n")

    return check_stats, score_pct


###############################
# Specific checks
###############################
# RECIPE:
# 1. Define check logic: throw error when it fails, do nothing on success
# 2. Initialize Check instance, which adds check to the registry

###############################
# Section 0 Checks
###############################
# I can't actually see Markdown content changes
check_0_1 = Check("0.1", lambda: None)


def check_0_2_fn():
    verify_var_change("my_name")
    verify_var_change("partners_name")


check_0_2 = Check("0.2", check_0_2_fn)

# This just checks that everything was imported, which if this check runs
# it necessarily was
check_0_3 = Check("0.3", lambda: None)

###############################
# Section 1 Checks
###############################


# --------------------------------------------------
# Exercise 1.1
# --------------------------------------------------
def check_1_1_fn():
    f = get_func("exercise_1_1")
    lines = f()
    assert_return_not_edit_me(lines, "1.1")

    if not isinstance(lines, list):
        raise TypeError("exercise 1.1 must return a list of strings.")

    if len(lines) != 4:
        raise AssertionError(
            f"exercise 1.1 expected 4 lines (header + 3 rows), got {len(lines)}."
        )

    if lines[0] != "name,age,nationality":
        raise AssertionError("exercise 1.1 header line is incorrect.")

    for i, line in enumerate(lines):
        if not isinstance(line, str):
            raise TypeError(f"exercise 1.1 line {i} is not a string.")


check_1_1 = Check("1.1", check_1_1_fn)


# --------------------------------------------------
# Exercise 1.2
# --------------------------------------------------
def check_1_2_fn():
    f = get_func("exercise_1_2")
    result = f()
    assert_return_not_edit_me(result, "1.2")

    if not isinstance(result, dict):
        raise TypeError("exercise 1.2 must return a dict.")

    expected_names = {"Hector", "Mattia", "Joey"}
    if set(result.keys()) != expected_names:
        raise AssertionError(
            f"exercise 1.2 keys must be {expected_names}, got {set(result.keys())}."
        )

    for name, value in result.items():
        if not isinstance(value, tuple) or len(value) != 2:
            raise TypeError(
                f"exercise 1.2 value for '{name}' must be a tuple (age, nationality)."
            )

        age, nationality = value

        if not isinstance(age, int):
            raise TypeError(f"exercise 1.2 age for '{name}' must be int.")

        if not isinstance(nationality, str):
            raise TypeError(f"exercise 1.2 nationality for '{name}' must be str.")


check_1_2 = Check("1.2", check_1_2_fn)


# --------------------------------------------------
# Exercise 1.3
# --------------------------------------------------
def check_1_3_fn():
    f = get_func("exercise_1_3")
    csv_out = f()
    assert_return_not_edit_me(csv_out, "1.3")

    if not isinstance(csv_out, str):
        raise TypeError("exercise 1.3 must return a string.")

    lines = csv_out.strip().split("\n")

    if lines[0] != "name,age,nationality":
        raise AssertionError("exercise 1.3 header must be 'name,age,nationality'.")

    if len(lines) != 4:
        raise AssertionError(f"exercise 1.3 expected 4 lines total, got {len(lines)}.")

    names = {line.split(",")[0] for line in lines[1:]}
    if names != {"Hector", "Mattia", "Joey"}:
        raise AssertionError("exercise 1.3 row data is incorrect.")


check_1_3 = Check("1.3", check_1_3_fn)


# --------------------------------------------------
# Exercise 1.4
# --------------------------------------------------
def check_1_4_fn():
    f = get_func("exercise_1_4")
    obj = f()
    assert_return_not_edit_me(obj, "1.4")

    if not isinstance(obj, dict):
        raise TypeError("exercise 1.4 must return a dict.")

    if obj.get("name") != "Hector":
        raise AssertionError("exercise 1.4 name must be 'Hector'.")

    if obj.get("age") != 20:
        raise AssertionError("exercise 1.4 age must be 20.")

    hobbies = obj.get("hobbies")
    if hobbies != ["running", "painting"]:
        raise AssertionError("exercise 1.4 hobbies must be ['running', 'painting'].")


check_1_4 = Check("1.4", check_1_4_fn)


# --------------------------------------------------
# Exercise 1.5
# --------------------------------------------------
def check_1_5_fn():
    f = get_func("exercise_1_5")
    s = f()
    assert_return_not_edit_me(s, "1.5")

    if not isinstance(s, str):
        raise TypeError("exercise 1.5 must return a JSON string.")

    try:
        obj = json.loads(s)
    except Exception as e:
        raise AssertionError(f"exercise 1.5 returned invalid JSON: {e}")

    if obj.get("name") != "Marco":
        raise AssertionError("exercise 1.5 name must be 'Marco'.")

    if obj.get("age") != 19 or not isinstance(obj["age"], int):
        raise AssertionError("exercise 1.5 age must be int 19.")

    if obj.get("favorite_subjects") != ["Math", "Physics"]:
        raise AssertionError("exercise 1.5 favorite_subjects incorrect.")


check_1_5 = Check("1.5", check_1_5_fn)


# --------------------------------------------------
# Exercise 1.6
# --------------------------------------------------
def check_1_6_fn():
    f = get_func("exercise_1_6")
    result = f()
    assert_return_not_edit_me(result, "1.6")

    if not isinstance(result, tuple) or len(result) != 3:
        raise TypeError(
            "exercise 1.6 must return a tuple (age, second_hobby, avg_screen_time_min)."
        )

    age, hobby, avg = result

    if age != 18:
        raise AssertionError("exercise 1.6 age must be 18.")

    if hobby != "music":
        raise AssertionError("exercise 1.6 second hobby must be 'music'.")

    if avg != 320:
        raise AssertionError("exercise 1.6 avg_screen_time_min must be 320.")


check_1_6 = Check("1.6", check_1_6_fn)


###############################
# Section 2 Checks
###############################


def _reset_temp_db():
    if os.path.exists("temp.db"):
        os.remove("temp.db")


def _fetchall(sql: str):
    with sqlite3.connect("temp.db") as conn:
        conn.execute("PRAGMA foreign_keys = ON;")
        cur = conn.execute(sql)
        return cur.fetchall()


def _table_info(table_name: str):
    with sqlite3.connect("temp.db") as conn:
        conn.execute("PRAGMA foreign_keys = ON;")
        cur = conn.execute(f"PRAGMA table_info({table_name});")
        return cur.fetchall()


# --------------------------------------------------
# Exercise 2.1
# --------------------------------------------------
def check_2_1_fn():
    _reset_temp_db()
    f = get_func("exercise_2_1")
    sql_command = f()
    assert_return_not_edit_me(sql_command, "2.1")

    if not isinstance(sql_command, str):
        raise TypeError("exercise 2.1 must return a SQL string.")

    schema = _table_info("Students")
    if not schema:
        raise AssertionError("Students table was not created (or name is wrong).")

    # PRAGMA table_info returns: cid, name, type, notnull, dflt_value, pk
    expected_cols = [
        ("id", "INTEGER", 1),
        ("name", "TEXT", 0),
        ("age", "INTEGER", 0),
        ("favorite_food", "TEXT", 0),
    ]

    if len(schema) != len(expected_cols):
        raise AssertionError(
            f"Students table must have {len(expected_cols)} columns, got {len(schema)}."
        )

    for i, (exp_name, exp_type, exp_pk) in enumerate(expected_cols):
        _, name, col_type, _, _, pk = schema[i]
        if name != exp_name:
            raise AssertionError(f"Column {i} must be '{exp_name}', got '{name}'.")
        if (col_type or "").upper() != exp_type:
            raise AssertionError(
                f"Column '{exp_name}' must be type '{exp_type}', got '{col_type}'."
            )
        if pk != exp_pk:
            raise AssertionError(
                f"Column '{exp_name}' pk flag must be {exp_pk}, got {pk}."
            )


check_2_1 = Check("2.1", check_2_1_fn)


# --------------------------------------------------
# Exercise 2.2
# --------------------------------------------------
def check_2_2_fn():
    _reset_temp_db()
    get_func("exercise_2_1")()

    f = get_func("exercise_2_2")
    sql_command = f()
    assert_return_not_edit_me(sql_command, "2.2")

    rows = _fetchall("SELECT name, age, favorite_food FROM Students ORDER BY id;")
    if len(rows) != 1:
        raise AssertionError(
            f"exercise 2.2 must insert exactly 1 row, got {len(rows)}."
        )

    # We keep this flexible: students can choose their own values for 2.2,
    # but the row must be complete and correctly typed.
    name, age, food = rows[0]
    if not isinstance(name, str) or not name:
        raise AssertionError("exercise 2.2 inserted name must be a non-empty string.")
    if not isinstance(age, int):
        raise AssertionError("exercise 2.2 inserted age must be an integer.")
    if not isinstance(food, str) or not food:
        raise AssertionError(
            "exercise 2.2 inserted favorite_food must be a non-empty string."
        )


check_2_2 = Check("2.2", check_2_2_fn)


def _setup_students_table():
    _reset_temp_db()
    get_func("exercise_2_1")()
    get_func("exercise_2_2")()
    get_func("exercise_2_3")()


# --------------------------------------------------
# Exercise 2.3
# --------------------------------------------------
def check_2_3_fn():
    _reset_temp_db()
    get_func("exercise_2_1")()
    get_func("exercise_2_2")()

    f = get_func("exercise_2_3")
    sql_script = f()
    assert_return_not_edit_me(sql_script, "2.3")

    rows = _fetchall("SELECT name, age, favorite_food FROM Students ORDER BY id;")
    if len(rows) != 4:
        raise AssertionError(
            f"exercise 2.3 must result in 4 total rows, got {len(rows)}."
        )

    # For downstream determinism (2.4), we require these exact additional inserts.
    inserted = set(rows[1:])  # skip the first row from 2.2
    expected = {
        ("Mattia", 28, "pizza"),
        ("Joey", 19, "burgers"),
        ("Elena", 21, "risotto"),
    }
    if inserted != expected:
        raise AssertionError(
            f"exercise 2.3 must insert exactly {expected} (in any order), got {inserted}."
        )


check_2_3 = Check("2.3", check_2_3_fn)


# --------------------------------------------------
# Exercise 2.4
# --------------------------------------------------
def check_2_4_fn():
    _setup_students_table()

    f = get_func("exercise_2_4")
    sql_query, results = f()
    assert_return_not_edit_me(sql_query, "2.4")
    assert_return_not_edit_me(results, "2.4")

    if not isinstance(sql_query, str):
        raise TypeError("exercise 2.4 must return sql_query as a string.")
    if not isinstance(results, list):
        raise TypeError("exercise 2.4 must return results as a list of tuples.")

    expected = [("Mattia", 28), ("Elena", 21)]
    if results != expected:
        raise AssertionError(
            f"exercise 2.4 expected results {expected}, got {results}."
        )


check_2_4 = Check("2.4", check_2_4_fn)


# --------------------------------------------------
# Exercise 2.5
# --------------------------------------------------
def check_2_5_fn():
    _setup_students_table()

    f = get_func("exercise_2_5")
    result = f()
    
    if not isinstance(result, tuple) or len(result) != 4:
        raise TypeError(
            "exercise 2.5 must return a tuple of 4 elements: "
            "(create_table_sql, insert_sql, query_sql_text, query_results)"
        )
    
    create_table_sql, insert_sql, query_sql_text, query_results = result
    
    assert_return_not_edit_me(create_table_sql, "2.5")
    assert_return_not_edit_me(insert_sql, "2.5")
    assert_return_not_edit_me(query_sql_text, "2.5")
    assert_return_not_edit_me(query_results, "2.5")

    # Verify the Friends table was created with correct schema
    try:
        schema = _table_info("Friends")
    except Exception:
        raise AssertionError("Friends table was not created (or name is wrong).")
    
    if not schema:
        raise AssertionError("Friends table was not created (or name is wrong).")
    
    # Check columns exist (order may vary)
    col_names = {col[1] for col in schema}  # col[1] is the column name
    expected_cols = {"id", "first_student_id", "second_student_id"}
    if col_names != expected_cols:
        raise AssertionError(
            f"Friends table must have columns {expected_cols}, got {col_names}."
        )
    
    # Verify foreign keys were created (check schema)
    # Note: This is a basic check; sqlite3 PRAGMA foreign_key_list would be more thorough
    col_types = {col[1]: col[2] for col in schema}  # name: type
    if col_types.get("first_student_id") != "INTEGER":
        raise AssertionError("first_student_id must be INTEGER type.")
    if col_types.get("second_student_id") != "INTEGER":
        raise AssertionError("second_student_id must be INTEGER type.")
    
    # Verify insertions
    friends_rows = _fetchall("SELECT first_student_id, second_student_id FROM Friends ORDER BY id;")
    if len(friends_rows) != 3:
        raise AssertionError(
            f"exercise 2.5 must insert exactly 3 friend relationships, got {len(friends_rows)}."
        )
    
    # Check that the expected relationships exist (in either direction)
    relationships = set()
    for first, second in friends_rows:
        relationships.add((min(first, second), max(first, second)))
    
    # Expected: Elena(4)-Joey(3), You(1)-Partner(5), You(1)-Mattia(2)
    expected_relationships = {
        (3, 4),  # Elena and Joey
        (1, 5),  # You and Partner
        (1, 2),  # You and Mattia
    }
    
    if relationships != expected_relationships:
        raise AssertionError(
            f"exercise 2.5 must insert these friend pairs: {expected_relationships}, got {relationships}."
        )
    
    # Verify query results
    if not isinstance(query_results, list):
        raise TypeError("exercise 2.5 query_results must be a list of tuples.")
    
    # Extract names from results (they come as single-element tuples)
    friend_names = {row[0] for row in query_results}
    
    # Expected: Mattia (id=2) and partner name (id=5)
    # Partner name is the 5th student inserted
    expected_friends = {"Mattia", "partners_name"}  # We'll need to get the actual partner name
    
    # Get partner's actual name from Students table
    partner_row = _fetchall("SELECT name FROM Students WHERE id = 5;")
    if partner_row:
        partner_name = partner_row[0][0]
        expected_friends = {"Mattia", partner_name}
    
    if friend_names != expected_friends:
        raise AssertionError(
            f"exercise 2.5 query must return your friends (Mattia and your partner), got {friend_names}."
        )


check_2_5 = Check("2.5", check_2_5_fn)


###############################
# Section 3 Checks
###############################


# --------------------------------------------------
# Exercise 3.1
# --------------------------------------------------
def check_3_1_fn():
    f = get_func("exercise_3_1")
    result = f()
    
    if not isinstance(result, tuple) or len(result) != 3:
        raise TypeError(
            "exercise 3.1 must return a tuple of 3 elements: "
            "(client, database, collection)"
        )
    
    client, database, collection = result
    
    assert_return_not_edit_me(client, "3.1")
    assert_return_not_edit_me(database, "3.1")
    assert_return_not_edit_me(collection, "3.1")
    
    # Check that client is a mongomock client
    import mongomock
    if not isinstance(client, mongomock.MongoClient):
        raise TypeError(
            "exercise 3.1 client must be a mongomock.MongoClient instance. "
            "Use mongomock.MongoClient() to create it."
        )
    
    # Check that database is a Database instance
    if not isinstance(database, mongomock.Database):
        raise TypeError(
            "exercise 3.1 database must be a mongomock.Database instance. "
            "Access it using client.my_database or client['my_database']."
        )
    
    # Check that collection is a Collection instance
    if not isinstance(collection, mongomock.Collection):
        raise TypeError(
            "exercise 3.1 collection must be a mongomock.Collection instance. "
            "Access it using database.students or database['students']."
        )
    
    # Check correct names
    if database.name != "my_database":
        raise AssertionError(
            f"exercise 3.1 database must be named 'my_database', got '{database.name}'."
        )
    
    if collection.name != "students":
        raise AssertionError(
            f"exercise 3.1 collection must be named 'students', got '{collection.name}'."
        )


check_3_1 = Check("3.1", check_3_1_fn)


###############################
# Section 4 Checks
###############################


# --------------------------------------------------
# Exercise 4.1
# --------------------------------------------------
def check_4_1_fn():
    f = get_func("exercise_4_1")
    result = f()
    assert_return_not_edit_me(result, "4.1")

    if not isinstance(result, dict):
        raise TypeError("exercise 4.1 must return a dictionary (document).")

    required_keys = {"name", "age", "favorite_color"}
    if not required_keys.issubset(result.keys()):
        missing = required_keys - set(result.keys())
        raise AssertionError(
            f"exercise 4.1 document must have keys {required_keys}, missing {missing}."
        )

    if not isinstance(result["name"], str) or not result["name"]:
        raise AssertionError("exercise 4.1 'name' must be a non-empty string.")

    if not isinstance(result["age"], int):
        raise AssertionError("exercise 4.1 'age' must be an integer.")

    if not isinstance(result["favorite_color"], str) or not result["favorite_color"]:
        raise AssertionError("exercise 4.1 'favorite_color' must be a non-empty string.")


check_4_1 = Check("4.1", check_4_1_fn)


# --------------------------------------------------
# Exercise 4.2
# --------------------------------------------------
def check_4_2_fn():
    f = get_func("exercise_4_2")
    result = f()
    assert_return_not_edit_me(result, "4.2")

    if not isinstance(result, list):
        raise TypeError("exercise 4.2 must return a list of dictionaries.")

    if len(result) != 3:
        raise AssertionError(
            f"exercise 4.2 must insert exactly 3 documents, got {len(result)}."
        )

    required_keys = {"name", "age", "favorite_color"}
    for i, doc in enumerate(result):
        if not isinstance(doc, dict):
            raise TypeError(f"exercise 4.2 document {i} must be a dictionary.")
        if not required_keys.issubset(doc.keys()):
            missing = required_keys - set(doc.keys())
            raise AssertionError(
                f"exercise 4.2 document {i} missing keys: {missing}."
            )


check_4_2 = Check("4.2", check_4_2_fn)


# --------------------------------------------------
# Exercise 4.3
# --------------------------------------------------
def check_4_3_fn():
    # First run 4.1 and 4.2 to populate the collection
    get_func("exercise_4_1")()
    get_func("exercise_4_2")()

    f = get_func("exercise_4_3")
    result = f()
    assert_return_not_edit_me(result, "4.3")

    if not isinstance(result, tuple) or len(result) != 2:
        raise TypeError(
            "exercise 4.3 must return a tuple (single_result, all_adults)."
        )

    single_result, all_adults = result
    assert_return_not_edit_me(single_result, "4.3")
    assert_return_not_edit_me(all_adults, "4.3")

    if single_result is not None and not isinstance(single_result, dict):
        raise TypeError("exercise 4.3 single_result must be a dict or None.")

    if not isinstance(all_adults, list):
        raise TypeError("exercise 4.3 all_adults must be a list.")

    # Check that all_adults contains documents (could be empty if no one >= 18)
    for doc in all_adults:
        if not isinstance(doc, dict):
            raise TypeError("exercise 4.3 all_adults must contain dictionaries.")
        if "age" in doc and doc["age"] < 18:
            raise AssertionError(
                f"exercise 4.3 found student with age {doc['age']} in adults list."
            )


check_4_3 = Check("4.3", check_4_3_fn)


# --------------------------------------------------
# Exercise 4.4
# --------------------------------------------------
def check_4_4_fn():
    # Ensure 4.1 has run to insert the user's document
    get_func("exercise_4_1")()

    f = get_func("exercise_4_4")
    result = f()
    assert_return_not_edit_me(result, "4.4")

    if not isinstance(result, dict):
        raise TypeError("exercise 4.4 must return a dictionary.")

    if "school" not in result:
        raise AssertionError(
            "exercise 4.4 updated document must have a 'school' field."
        )

    if result["school"] != "ITIS Cannizzaro":
        raise AssertionError(
            f"exercise 4.4 'school' field must be 'ITIS Cannizzaro', got '{result['school']}'."
        )


check_4_4 = Check("4.4", check_4_4_fn)


# --------------------------------------------------
# Exercise 4.5
# --------------------------------------------------
def check_4_5_fn():
    f = get_func("exercise_4_5")
    result = f()

    # Result should be None (document was deleted)
    if result is not None:
        raise AssertionError(
            "exercise 4.5 should return None after deleting the temporary document. "
            f"Got {result} instead."
        )


check_4_5 = Check("4.5", check_4_5_fn)


# --------------------------------------------------
# Exercise 4.6
# --------------------------------------------------
def check_4_6_fn():
    f = get_func("exercise_4_6")
    result = f()
    assert_return_not_edit_me(result, "4.6")

    if not isinstance(result, list):
        raise TypeError("exercise 4.6 must return a list of course names.")

    if len(result) != 2:
        raise AssertionError(
            f"exercise 4.6 must return 2 course names, got {len(result)}."
        )

    expected_courses = {"Mathematics", "Physics"}
    result_set = set(result)

    if result_set != expected_courses:
        raise AssertionError(
            f"exercise 4.6 must return course names {expected_courses}, got {result_set}."
        )


check_4_6 = Check("4.6", check_4_6_fn)


###############################
# Section 5 Checks
###############################

# Required schema fields for ITIS Cannizzaro dataset
REQUIRED_SCHEMA = {
    "dataset_source": str,
    "demographics": {
        "age": int,
        "siblings": int,
        "commute_time_minutes": int,
    },
    "interests": {
        "career_interest": str,
        "favorite_subject": str,
        "hobbies": list,
    },
    "digital_metrics": {
        "avg_screen_time_min": int,
        "unread_emails": int,
        "phone_pickups_daily": int,
        "notifications_daily": int,
    },
}


def _count_fields(doc: dict) -> int:
    """Count total fields in a nested document."""
    count = 0
    for key, value in doc.items():
        count += 1
        if isinstance(value, dict):
            count += _count_fields(value)
    return count


def _validate_profile_schema(profile: dict, exercise_id: str) -> None:
    """Validate that a profile follows the required schema."""
    if not isinstance(profile, dict):
        raise TypeError(f"exercise {exercise_id} profile must be a dictionary.")

    # Check dataset_source
    if "dataset_source" not in profile:
        raise AssertionError(
            f"exercise {exercise_id} profile missing 'dataset_source' field."
        )
    if profile["dataset_source"] != "real":
        raise AssertionError(
            f"exercise {exercise_id} 'dataset_source' must be 'real', got '{profile['dataset_source']}'."
        )

    # Check demographics
    if "demographics" not in profile:
        raise AssertionError(
            f"exercise {exercise_id} profile missing 'demographics' section."
        )
    demo = profile["demographics"]
    if not isinstance(demo, dict):
        raise TypeError(f"exercise {exercise_id} 'demographics' must be a dictionary.")
    for field in ["age", "siblings", "commute_time_minutes"]:
        if field not in demo:
            raise AssertionError(
                f"exercise {exercise_id} demographics missing '{field}'."
            )
        if not isinstance(demo[field], int):
            raise TypeError(
                f"exercise {exercise_id} demographics.{field} must be an integer."
            )

    # Check interests
    if "interests" not in profile:
        raise AssertionError(
            f"exercise {exercise_id} profile missing 'interests' section."
        )
    interests = profile["interests"]
    if not isinstance(interests, dict):
        raise TypeError(f"exercise {exercise_id} 'interests' must be a dictionary.")
    for field in ["career_interest", "favorite_subject"]:
        if field not in interests:
            raise AssertionError(f"exercise {exercise_id} interests missing '{field}'.")
        if not isinstance(interests[field], str):
            raise TypeError(
                f"exercise {exercise_id} interests.{field} must be a string."
            )
    if "hobbies" not in interests:
        raise AssertionError(f"exercise {exercise_id} interests missing 'hobbies'.")
    if not isinstance(interests["hobbies"], list):
        raise TypeError(f"exercise {exercise_id} interests.hobbies must be a list.")
    if len(interests["hobbies"]) == 0:
        raise AssertionError(
            f"exercise {exercise_id} interests.hobbies must have at least one hobby."
        )

    # Check digital_metrics
    if "digital_metrics" not in profile:
        raise AssertionError(
            f"exercise {exercise_id} profile missing 'digital_metrics' section."
        )
    metrics = profile["digital_metrics"]
    if not isinstance(metrics, dict):
        raise TypeError(
            f"exercise {exercise_id} 'digital_metrics' must be a dictionary."
        )
    for field in [
        "avg_screen_time_min",
        "unread_emails",
        "phone_pickups_daily",
        "notifications_daily",
    ]:
        if field not in metrics:
            raise AssertionError(
                f"exercise {exercise_id} digital_metrics missing '{field}'."
            )
        if not isinstance(metrics[field], int):
            raise TypeError(
                f"exercise {exercise_id} digital_metrics.{field} must be an integer."
            )


def _has_custom_field(profile: dict) -> bool:
    """Check if profile has at least one field beyond the required schema."""
    # Count expected fields: dataset_source + 3 sections with their fields
    # dataset_source (1) + demographics (3) + interests (3) + digital_metrics (4) = 11
    # Plus the 3 section keys themselves = 14 total minimum fields
    base_field_count = 14

    total_fields = _count_fields(profile)
    return total_fields > base_field_count


# --------------------------------------------------
# Exercise 5.1
# --------------------------------------------------
def check_5_1_fn():
    f = get_func("exercise_5_1")
    profile = f()
    assert_return_not_edit_me(profile, "5.1")

    _validate_profile_schema(profile, "5.1")

    # Check for custom field
    if not _has_custom_field(profile):
        raise AssertionError(
            "exercise 5.1 profile must include at least ONE custom field "
            "beyond the required schema. Be creative!"
        )


check_5_1 = Check("5.1", check_5_1_fn)


# --------------------------------------------------
# Exercise 5.2
# --------------------------------------------------
def check_5_2_fn():
    f = get_func("exercise_5_2")
    result = f()
    assert_return_not_edit_me(result, "5.2")

    if not isinstance(result, tuple) or len(result) != 3:
        raise TypeError(
            "exercise 5.2 must return a tuple (your_profile, partners_profile, all_profiles)."
        )

    my_profile, partners_profile, all_profiles = result
    assert_return_not_edit_me(my_profile, "5.2")
    assert_return_not_edit_me(partners_profile, "5.2")
    assert_return_not_edit_me(all_profiles, "5.2")

    # Validate both profiles
    _validate_profile_schema(my_profile, "5.2 (your profile)")
    _validate_profile_schema(partners_profile, "5.2 (partner's profile)")

    # Check for custom fields in both
    if not _has_custom_field(my_profile):
        raise AssertionError(
            "exercise 5.2 your profile must include at least ONE custom field."
        )
    if not _has_custom_field(partners_profile):
        raise AssertionError(
            "exercise 5.2 partner's profile must include at least ONE custom field."
        )

    # Verify all_profiles is a list with at least 2 documents
    if not isinstance(all_profiles, list):
        raise TypeError("exercise 5.2 all_profiles must be a list.")
    if len(all_profiles) < 2:
        raise AssertionError(
            f"exercise 5.2 all_profiles must contain at least 2 documents, got {len(all_profiles)}."
        )


check_5_2 = Check("5.2", check_5_2_fn)