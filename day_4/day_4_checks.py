# @Time    : 2026-01-08 19:34
# @Author  : Hector Astrom
# @Email   : hastrom@mit.edu
# @File    : day_4_checks.py

# DO NOT EDIT THIS FILE

import __main__ as NOTEBOOK_SCOPE  # context from notebook
from typing import Callable, Any, Dict, List, Tuple
from datetime import datetime
import hashlib
import sys
import io


###############################
# Helpers - REUSABLE CODE
###############################
class Check:  # stub
    pass


check_registry: dict[str, Check] = dict()  # maps check_id : Check() instance


class Check:
    def __init__(self, check_id: str, check_function: Callable):
        self.check_id = check_id
        self.last_ran = None
        self.check_function = check_function  # particular check instance logic
        check_registry[check_id] = self  # class instance

    def __call__(self, *args, update_time=True, **kwds):
        if update_time:
            self.last_ran = datetime.now()  # keep track of last time it ran

        return self.check_function(*args, **kwds)


def run_check(check_id: str, *args, silent=False, **kwargs):
    assert check_id in check_registry, f"ERROR: Missing check for exercise {check_id}"
    check_registry[check_id](*args, **kwargs)
    # Invariant: checks must throw a DESCRIPTIVE error if they fail
    # otherwise, they've passed!
    if not silent:
        print(f"Passed Exercise {check_id}!")
    return True


def is_defined(variable_name: str):
    if hasattr(NOTEBOOK_SCOPE, variable_name):
        return True
    raise NameError(f"'{variable_name}' is not defined in the notebook!")


def get_var(variable_name: str):
    if is_defined(variable_name):
        return getattr(NOTEBOOK_SCOPE, variable_name)


def get_func(func_name: str) -> Callable:
    """Helper specifically for grabbing and validating student functions"""
    f = get_var(func_name)
    if not callable(f):
        raise TypeError(
            f"'{func_name}' was found, but it is not a function. Check your syntax!"
        )
    return f


def verify_var_change(variable_name: str):
    assert get_var(variable_name) != "EDIT ME", (
        f"You forgot to edit '{variable_name}'. "
        f"\nFIX: Scroll up, edit '{variable_name}' where it says 'EDIT ME', and rerun the cell"
    )


def _assert_no_placeholder(value: Any, exercise_id: str) -> None:
    """Check that value does not contain 'EDIT ME' or 'EDIT' placeholder text."""
    if isinstance(value, str):
        text = value
    else:
        try:
            import json
            text = json.dumps(value, default=str)
        except Exception:
            text = str(value)

    if "EDIT ME" in text or text == "EDIT":
        raise AssertionError(
            f"Exercise {exercise_id} still contains placeholder text. Fix it and rerun the cell."
        )


# for file integrity verification
def get_file_hash() -> str:
    """Generates a SHA-256 hash of the current file's content."""
    with open(__file__, "rb") as f:
        # any change triggers a completely new hash
        return hashlib.sha256(f.read()).hexdigest()[:12]  # shortened


def run_all_checks(skip_checks: list[str] = None) -> tuple[dict, float]:
    """
    Runs all checks, prints a status table, and provides an integrity hash.
    """
    skip_checks = skip_checks or []
    check_stats = {}
    total_correct = 0

    # generate fingerprint of the checks.py file
    integrity_fingerprint = get_file_hash()

    # start printing table
    print(f"\n{'='*60}")
    print(f"{'EXERCISE CHECKER SUMMARY':^60}")
    print(f"{'Integrity Hash: ' + integrity_fingerprint:^60}")
    print(f"{'='*60}\n")

    header = f"{'Exercise':<12} | {'Status':<10} | {'Last Verified'}"
    print(header)
    print("-" * len(header))

    for check_id, check in check_registry.items():
        if check_id in skip_checks:
            continue

        # Suppress print output from exercise functions
        old_stdout = sys.stdout
        sys.stdout = io.StringIO()

        try:
            # Invariant: Checks pass if no exception is raised
            check(update_time=False)
            status_icon = "OK"
            passed = True
            total_correct += 1
        except Exception:
            status_icon = "WRONG"
            passed = False
        finally:
            # Restore stdout
            sys.stdout = old_stdout

        last_ran_str = (
            check.last_ran.strftime("%m-%d %H:%M") if check.last_ran else "NEVER"
        )
        check_stats[check_id] = (passed, last_ran_str)

        # Print table row
        print(f"{check_id:<12} | {status_icon:<10} | {last_ran_str}")

    # Final Score logic
    num_checks = len(check_registry) - len(skip_checks)
    score_pct = (total_correct / num_checks) if num_checks > 0 else 0

    print(f"\n{'-'*60}")
    print(f"Completed: {total_correct}/{num_checks} ({score_pct:.1%})")
    print(f"{'-'*60}\n")

    return check_stats, score_pct


###############################
# Specific checks
###############################
# RECIPE:
# 1. Define check logic: throw error when it fails, do nothing on success
# 2. Initialize Check instance, which adds check to the registry


###############################
# Section 0 Checks
###############################
check_0_1 = Check("0.1", lambda: None)


###############################
# Section 1 Checks - Data Standardization
###############################

def _check_1_1():
    """Check that string_scrubber correctly cleans strings."""
    func = get_func("exercise_1_1")
    string_scrubber = func()
    
    assert callable(string_scrubber), "exercise_1_1 must return a function"
    
    # Test with the example from the exercise
    result = string_scrubber(" dIRty StRing   ")
    assert result == "dirty string", (
        f"string_scrubber(' dIRty StRing   ') should return 'dirty string', got '{result}'"
    )
    
    # Test with another case
    result2 = string_scrubber("  HELLO World  ")
    assert result2 == "hello world", (
        f"string_scrubber('  HELLO World  ') should return 'hello world', got '{result2}'"
    )


check_1_1 = Check("1.1", _check_1_1)


def _check_1_2():
    """Check that is_valid function works correctly."""
    func = get_func("exercise_1_2")
    result = func()
    
    assert isinstance(result, tuple) and len(result) == 4, (
        "exercise_1_2 must return a tuple of (function, valid_a, valid_b, valid_c)"
    )
    
    is_valid, valid_a, valid_b, valid_c = result
    
    assert callable(is_valid), "First return value must be the is_valid function"
    assert valid_a == True, "string_a ('apple') should be valid (in options)"
    assert valid_b == False, "string_b ('oranges') should be invalid (not in options - note the 's')"
    assert valid_c == False, "string_c ('cherry') should be invalid (not in options)"
    
    # Test the function with custom inputs
    test_result = is_valid("banana", ["apple", "banana", "orange"])
    assert test_result == True, "is_valid('banana', ['apple', 'banana', 'orange']) should be True"


check_1_2 = Check("1.2", _check_1_2)


def _check_1_3():
    """Check one-hot encoding implementation."""
    func = get_func("exercise_1_3")
    one_hot = func()
    
    _assert_no_placeholder(one_hot, "1.3")
    
    assert isinstance(one_hot, list), "exercise_1_3 must return a list"
    assert len(one_hot) == 5, "one_hot_encoding should have 5 elements (one per fruit)"
    
    expected = [0, 0, 0, 1, 0]  # kiwi is at index 3
    assert one_hot == expected, (
        f"one_hot_encoding for 'kiwi' should be {expected}, got {one_hot}"
    )


check_1_3 = Check("1.3", _check_1_3)


###############################
# Section 2 Checks - Pydantic
###############################

def _check_2_1():
    """Check MiniStudentV1 model definition."""
    func = get_func("exercise_2_1")
    student = func()
    
    # Check that MiniStudentV1 class exists
    MiniStudentV1 = get_var("MiniStudentV1")
    
    from pydantic import BaseModel
    assert issubclass(MiniStudentV1, BaseModel), "MiniStudentV1 must inherit from BaseModel"
    
    # Check field types
    fields = MiniStudentV1.model_fields
    assert "name" in fields, "MiniStudentV1 must have a 'name' field"
    assert "siblings" in fields, "MiniStudentV1 must have a 'siblings' field"
    
    # Check the instance
    assert student.name == "Elena", f"student.name should be 'Elena', got '{student.name}'"
    assert student.siblings == 12, f"student.siblings should be 12, got {student.siblings}"
    
    # Verify types are correct (not Any)
    name_annotation = fields["name"].annotation
    siblings_annotation = fields["siblings"].annotation
    
    assert name_annotation == str or name_annotation is str, (
        f"name field should be typed as str, not {name_annotation}"
    )
    assert siblings_annotation == int or siblings_annotation is int, (
        f"siblings field should be typed as int, not {siblings_annotation}"
    )


check_2_1 = Check("2.1", _check_2_1)


def _check_2_2():
    """Check MiniStudentV2 with age constraints."""
    func = get_func("exercise_2_2")
    student = func()
    
    MiniStudentV2 = get_var("MiniStudentV2")
    
    from pydantic import BaseModel, ValidationError
    assert issubclass(MiniStudentV2, BaseModel), "MiniStudentV2 must inherit from BaseModel"
    
    # Check that age field exists
    fields = MiniStudentV2.model_fields
    assert "age" in fields, "MiniStudentV2 must have an 'age' field"
    
    # Check the returned student
    assert student.age == 104, f"student.age should be 104, got {student.age}"
    
    # Test that invalid ages are rejected
    try:
        MiniStudentV2(name="Test", siblings=0, age=140)
        raise AssertionError("MiniStudentV2 should reject age=140 (too old)")
    except ValidationError:
        pass  # Expected
    
    try:
        MiniStudentV2(name="Test", siblings=0, age=10)
        raise AssertionError("MiniStudentV2 should reject age=10 (too young)")
    except ValidationError:
        pass  # Expected
    
    # Valid age should work
    valid_student = MiniStudentV2(name="Test", siblings=0, age=25)
    assert valid_student.age == 25


check_2_2 = Check("2.2", _check_2_2)


def _check_2_3():
    """Check serialization/deserialization."""
    func = get_func("exercise_2_3")
    student_dict = func()
    
    _assert_no_placeholder(student_dict, "2.3")
    
    assert isinstance(student_dict, dict), "exercise_2_3 must return a dict"
    
    # The age should have been changed from the original (104)
    assert "age" in student_dict, "student_dict must contain 'age' key"
    assert student_dict["age"] != 104, (
        "You need to change the age to something other than 104"
    )
    
    # Should still have the other fields
    assert "name" in student_dict, "student_dict must contain 'name' key"
    assert "siblings" in student_dict, "student_dict must contain 'siblings' key"


check_2_3 = Check("2.3", _check_2_3)


###############################
# Section 3 Checks - Database
###############################

def _check_3_1():
    """Check MongoDB connection."""
    func = get_func("exercise_3_1")
    result = func()
    
    assert isinstance(result, tuple) and len(result) == 3, (
        "exercise_3_1 must return (client, database, collection)"
    )
    
    client, database, collection = result
    
    from pymongo.mongo_client import MongoClient
    assert isinstance(client, MongoClient), "First return value must be a MongoClient"
    
    # Test connection by pinging
    try:
        client.admin.command("ping")
    except Exception as e:
        raise ConnectionError(
            f"Could not connect to MongoDB. Check your connection string. Error: {e}"
        )
    
    assert database.name == "itis-cannizzaro", (
        f"Database name should be 'itis-cannizzaro', got '{database.name}'"
    )
    assert collection.name == "students", (
        f"Collection name should be 'students', got '{collection.name}'"
    )


check_3_1 = Check("3.1", _check_3_1)


# Note: Exercise 3.2 has no automated check - it inserts student data
# which requires manual review to avoid duplicate/test data


def _check_3_3():
    """Check that student saved their IDs and aliases."""
    func = get_func("exercise_3_3")
    result = func()
    
    assert isinstance(result, tuple) and len(result) == 2, (
        "exercise_3_3 must return (my_ids, my_aliases)"
    )
    
    my_ids, my_aliases = result
    
    _assert_no_placeholder(my_ids, "3.3")
    _assert_no_placeholder(my_aliases, "3.3")
    
    assert isinstance(my_ids, list), "my_ids must be a list"
    assert isinstance(my_aliases, list), "my_aliases must be a list"
    
    assert len(my_ids) >= 1, "You must have at least one ID saved"
    assert len(my_aliases) >= 1, "You must have at least one alias saved"
    
    # Check that IDs look like ObjectIds (24 hex characters)
    for id_str in my_ids:
        assert isinstance(id_str, str), f"Each ID should be a string, got {type(id_str)}"
        assert len(id_str) == 24, (
            f"ObjectId strings should be 24 characters, got {len(id_str)} for '{id_str}'"
        )
        # Check it's valid hex
        try:
            int(id_str, 16)
        except ValueError:
            raise AssertionError(f"'{id_str}' is not a valid ObjectId hex string")


check_3_3 = Check("3.3", _check_3_3)
