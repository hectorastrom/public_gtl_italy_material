# @Time    : 2026-01-20 16:23
# @Author  : Hector Astrom
# @Email   : hastrom@mit.edu
# @File    : day_5_checks.py

# DO NOT EDIT THIS FILE

import __main__ as NOTEBOOK_SCOPE  # context from notebook
from typing import Callable, Any, Dict, List, Tuple
from datetime import datetime
import hashlib
import sys
import io


###############################
# Helpers - REUSABLE CODE
###############################
class Check:  # stub
    pass


check_registry: dict[str, Check] = dict()  # maps check_id : Check() instance


class Check:
    def __init__(self, check_id: str, check_function: Callable):
        self.check_id = check_id
        self.last_ran = None
        self.check_function = check_function  # particular check instance logic
        check_registry[check_id] = self  # class instance

    def __call__(self, *args, update_time=True, **kwds):
        if update_time:
            self.last_ran = datetime.now()  # keep track of last time it ran

        return self.check_function(*args, **kwds)


def run_check(check_id: str, *args, silent=False, **kwargs):
    assert check_id in check_registry, f"ERROR: Missing check for exercise {check_id}"
    check_registry[check_id](*args, **kwargs)
    # Invariant: checks must throw a DESCRIPTIVE error if they fail
    # otherwise, they've passed!
    if not silent:
        print(f"Passed Exercise {check_id}!")
    return True


def is_defined(variable_name: str):
    if hasattr(NOTEBOOK_SCOPE, variable_name):
        return True
    raise NameError(f"'{variable_name}' is not defined in the notebook!")


def get_var(variable_name: str):
    if is_defined(variable_name):
        return getattr(NOTEBOOK_SCOPE, variable_name)


def get_func(func_name: str) -> Callable:
    """Helper specifically for grabbing and validating student functions"""
    f = get_var(func_name)
    if not callable(f):
        raise TypeError(
            f"'{func_name}' was found, but it is not a function. Check your syntax!"
        )
    return f


def verify_var_change(variable_name: str):
    assert get_var(variable_name) != "EDIT ME", (
        f"You forgot to edit '{variable_name}'. "
        f"\nFIX: Scroll up, edit '{variable_name}' where it says 'EDIT ME', and rerun the cell"
    )


def _assert_no_placeholder(value: Any, exercise_id: str) -> None:
    """Check that value does not contain 'EDIT ME' or 'EDIT' placeholder text."""
    if isinstance(value, str):
        text = value
    else:
        try:
            import json
            text = json.dumps(value, default=str)
        except Exception:
            text = str(value)

    if "EDIT ME" in text or text == "EDIT":
        raise AssertionError(
            f"Exercise {exercise_id} still contains placeholder text. Fix it and rerun the cell."
        )


# for file integrity verification
def get_file_hash() -> str:
    """Generates a SHA-256 hash of the current file's content."""
    with open(__file__, "rb") as f:
        # any change triggers a completely new hash
        return hashlib.sha256(f.read()).hexdigest()[:12]  # shortened


def run_all_checks(skip_checks: list[str] = None) -> tuple[dict, float]:
    """
    Runs all checks, prints a status table, and provides an integrity hash.
    """
    skip_checks = skip_checks or []
    check_stats = {}
    total_correct = 0

    # generate fingerprint of the checks.py file
    integrity_fingerprint = get_file_hash()

    # start printing table
    print(f"\n{'='*60}")
    print(f"{'EXERCISE CHECKER SUMMARY':^60}")
    print(f"{'Integrity Hash: ' + integrity_fingerprint:^60}")
    print(f"{'='*60}\n")

    header = f"{'Exercise':<12} | {'Status':<10} | {'Last Verified'}"
    print(header)
    print("-" * len(header))

    for check_id, check in check_registry.items():
        if check_id in skip_checks:
            continue

        # Suppress print output from exercise functions
        old_stdout = sys.stdout
        sys.stdout = io.StringIO()

        try:
            # Invariant: Checks pass if no exception is raised
            check(update_time=False)
            status_icon = "OK"
            passed = True
            total_correct += 1
        except Exception:
            status_icon = "INCOMPLETE"
            passed = False
        finally:
            # Restore stdout
            sys.stdout = old_stdout

        last_ran_str = (
            check.last_ran.strftime("%m-%d %H:%M") if check.last_ran else "NEVER"
        )
        check_stats[check_id] = (passed, last_ran_str)

        # Print table row
        print(f"{check_id:<12} | {status_icon:<15} | {last_ran_str}")

    # Final Score logic
    num_checks = len(check_registry) - len(skip_checks)
    score_pct = (total_correct / num_checks) if num_checks > 0 else 0

    print(f"\n{'-'*60}")
    print(f"Completed: {total_correct}/{num_checks} ({score_pct:.1%})")
    print(f"{'-'*60}\n")

    return check_stats, score_pct


###############################
# Specific checks
###############################
# RECIPE:
# 1. Define check logic: throw error when it fails, do nothing on success
# 2. Initialize Check instance, which adds check to the registry


###############################
# Section 0 Checks
###############################
check_0_1 = Check("0.1", lambda: None)


###############################
# Section 1 Checks - Feature Engineering
###############################

def _check_1_1():
    """Check that check_same returns 1 for equal fields and 0 otherwise."""
    func = get_func("exercise_1_1")
    check_same = func()

    assert callable(check_same), "exercise_1_1 must return a function"

    cases = [
        ("a", "a", 1),
        ("a", "b", 0),
        (1, 1, 1),
        (1, 2, 0),
    ]
    for left, right, expected in cases:
        result = check_same(left, right)
        assert result in (0, 1), "check_same must return 0 or 1"
        assert result == expected, (
            f"check_same({left}, {right}) should return {expected}, got {result}"
        )


check_1_1 = Check("1.1", _check_1_1)


def _check_1_2():
    """Check Jaccard similarity implementation."""
    func = get_func("exercise_1_2")
    jaccard_similarity = func()

    assert callable(jaccard_similarity), "exercise_1_2 must return a function"

    result = jaccard_similarity(["apple", "banana"], ["banana", "cherry"])
    expected = 1 / 3
    assert abs(result - expected) < 1e-9, (
        f"Expected Jaccard similarity {expected}, got {result}"
    )

    result_same = jaccard_similarity(["a", "b"], ["a", "b"])
    assert abs(result_same - 1.0) < 1e-9, (
        f"Expected Jaccard similarity 1.0 for identical sets, got {result_same}"
    )


check_1_2 = Check("1.2", _check_1_2)


def _check_1_3():
    """Check absolute difference function."""
    func = get_func("exercise_1_3")
    compute_abs_diff = func()

    assert callable(compute_abs_diff), "exercise_1_3 must return a function"

    result = compute_abs_diff(10, 4)
    assert result == 6, f"compute_abs_diff(10, 4) should return 6, got {result}"

    result_float = compute_abs_diff(2.5, 5.0)
    assert result_float == 2.5, (
        f"compute_abs_diff(2.5, 5.0) should return 2.5, got {result_float}"
    )


check_1_3 = Check("1.3", _check_1_3)


def _get_two_student_docs():
    students_collection = get_var("students_collection")
    docs = list(students_collection.find().limit(2))
    assert len(docs) >= 2, "Need at least two students in the database to run checks"
    return docs


def _check_1_4():
    """Check computed FriendshipFeatures values."""
    func = get_func("exercise_1_4")
    compute_friendship_features = func()

    assert callable(compute_friendship_features), "exercise_1_4 must return a function"

    docs = _get_two_student_docs()
    CannizzaroStudent = get_var("CannizzaroStudent")
    FriendshipFeatures = get_var("FriendshipFeatures")

    student1 = CannizzaroStudent(**docs[0])
    student2 = CannizzaroStudent(**docs[1])

    features = compute_friendship_features(student1, student2)
    assert isinstance(features, FriendshipFeatures), (
        "compute_friendship_features must return a FriendshipFeatures instance"
    )

    def _jaccard(left, right) -> float:
        set_left = set(left)
        set_right = set(right)
        union = set_left | set_right
        intersection = set_left & set_right
        return len(intersection) / len(union)

    expected_section_same = 1 if student1.demographics.class_section == student2.demographics.class_section else 0
    expected_subject_same = 1 if student1.academics.favorite_subject == student2.academics.favorite_subject else 0
    expected_sport_jaccard = _jaccard(student1.activities.sports, student2.activities.sports)
    expected_music_jaccard = _jaccard(student1.activities.music_genres, student2.activities.music_genres)
    expected_hobby_jaccard = _jaccard(student1.activities.hobbies, student2.activities.hobbies)
    expected_social_diff = abs(student1.behavioral.social_style - student2.behavioral.social_style)
    expected_academic_diff = abs(student1.academics.academic_interest - student2.academics.academic_interest)
    expected_sibling_diff = abs(student1.demographics.siblings - student2.demographics.siblings)
    expected_screen_diff = abs(student1.digital_metrics.avg_screen_time_min - student2.digital_metrics.avg_screen_time_min)
    expected_phone_diff = abs(student1.digital_metrics.phone_pickups_daily - student2.digital_metrics.phone_pickups_daily)

    assert features.section_same == expected_section_same, (
        f"section_same should be {expected_section_same}, got {features.section_same}"
    )
    assert features.favorite_subject_same == expected_subject_same, (
        f"favorite_subject_same should be {expected_subject_same}, got {features.favorite_subject_same}"
    )
    assert abs(features.sport_jaccard - expected_sport_jaccard) < 1e-9, (
        f"sport_jaccard should be {expected_sport_jaccard}, got {features.sport_jaccard}"
    )
    assert abs(features.music_genre_jaccard - expected_music_jaccard) < 1e-9, (
        f"music_genre_jaccard should be {expected_music_jaccard}, got {features.music_genre_jaccard}"
    )
    assert abs(features.hobby_jaccard - expected_hobby_jaccard) < 1e-9, (
        f"hobby_jaccard should be {expected_hobby_jaccard}, got {features.hobby_jaccard}"
    )
    assert features.social_style_diff == expected_social_diff, (
        f"social_style_diff should be {expected_social_diff}, got {features.social_style_diff}"
    )
    assert features.academic_interest_diff == expected_academic_diff, (
        f"academic_interest_diff should be {expected_academic_diff}, got {features.academic_interest_diff}"
    )
    assert features.sibling_count_diff == expected_sibling_diff, (
        f"sibling_count_diff should be {expected_sibling_diff}, got {features.sibling_count_diff}"
    )
    assert features.screen_time_diff == expected_screen_diff, (
        f"screen_time_diff should be {expected_screen_diff}, got {features.screen_time_diff}"
    )
    assert features.phone_pickups_diff == expected_phone_diff, (
        f"phone_pickups_diff should be {expected_phone_diff}, got {features.phone_pickups_diff}"
    )


check_1_4 = Check("1.4", _check_1_4)


###############################
# Section 2 Checks - Friendships
###############################

def _check_2_1():
    """Check find_by_alias function and deserialization."""
    func = get_func("exercise_2_1")
    find_by_alias = func()

    assert callable(find_by_alias), "exercise_2_1 must return a function"

    docs = _get_two_student_docs()
    alias = docs[0]["demographics"]["alias"]

    result = find_by_alias(alias)
    assert isinstance(result, dict), "find_by_alias must return a dict"
    assert alias in result, f"find_by_alias should return a dict containing key '{alias}'"

    CannizzaroStudent = get_var("CannizzaroStudent")
    student_model = result[alias]
    assert isinstance(student_model, CannizzaroStudent), (
        "find_by_alias values must be CannizzaroStudent objects"
    )
    assert student_model.demographics.alias == alias, (
        f"Returned student alias should be '{alias}', got '{student_model.demographics.alias}'"
    )
    assert hasattr(student_model, "_id"), (
        "CannizzaroStudent instance should have _id attached for friendship creation"
    )


check_2_1 = Check("2.1", _check_2_1)


def _check_2_2():
    """Check friendship creation."""
    func = get_func("exercise_2_2")
    create_friendship_by_alias = func()

    assert callable(create_friendship_by_alias), "exercise_2_2 must return a function"

    docs = _get_two_student_docs()
    alias_1 = docs[0]["demographics"]["alias"]
    alias_2 = docs[1]["demographics"]["alias"]

    friendship = create_friendship_by_alias(alias_1, alias_2, True)
    Friendship = get_var("Friendship")
    FriendshipFeatures = get_var("FriendshipFeatures")

    assert isinstance(friendship, Friendship), "create_friendship_by_alias must return a Friendship"
    assert friendship.is_positive_friendship == True, "is_positive_friendship should match input"
    assert isinstance(friendship.features, FriendshipFeatures), "features must be FriendshipFeatures"

    expected_low, expected_high = sorted([str(docs[0]["_id"]), str(docs[1]["_id"])])
    assert str(friendship.person_low_id) == expected_low, (
        f"person_low_id should be {expected_low}, got {friendship.person_low_id}"
    )
    assert str(friendship.person_high_id) == expected_high, (
        f"person_high_id should be {expected_high}, got {friendship.person_high_id}"
    )


check_2_2 = Check("2.2", _check_2_2)


def _check_2_3():
    """Check friendship insertions."""
    func = get_func("exercise_2_3")
    inserted_statuses = func()

    assert isinstance(inserted_statuses, list), "exercise_2_3 must return a list"
    assert len(inserted_statuses) >= 4, "exercise_2_3 should insert at least 4 friendships"

    for status in inserted_statuses:
        assert isinstance(status, bool), "Each insertion status must be a boolean"


check_2_3 = Check("2.3", _check_2_3)